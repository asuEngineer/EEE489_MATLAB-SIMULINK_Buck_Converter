var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"buck_converter_w_feedback","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw","tag":"","groupDisplay":"Main file","code":"#include \"buck_converter_w_feedback.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\nvolatile int IsrOverrun = 0;\r\nstatic boolean_T OverrunFlag = 0;\r\nvoid rt_OneStep(void)\r\n{\r\n  /* Check for overrun. Protect OverrunFlag against preemption */\r\n  if (OverrunFlag++) {\r\n    IsrOverrun = 1;\r\n    OverrunFlag--;\r\n    return;\r\n  }\r\n\r\n#ifndef _MW_ARDUINO_LOOP_\r\n\r\n  interrupts();\r\n\r\n#endif;\r\n\r\n  buck_converter_w_feedback_step();\r\n\r\n  /* Get model outputs here */\r\n#ifndef _MW_ARDUINO_LOOP_\r\n\r\n  noInterrupts();\r\n\r\n#endif;\r\n\r\n  OverrunFlag--;\r\n}\r\n\r\nvolatile boolean_T stopRequested;\r\nvolatile boolean_T runModel;\r\nint main(void)\r\n{\r\n  float modelBaseRate = 0.001;\r\n  float systemClock = 0;\r\n\r\n  /* Initialize variables */\r\n  stopRequested = false;\r\n  runModel = false;\r\n  MW_Arduino_Init();\r\n  rtmSetErrorStatus(buck_converter_w_feedback_M, 0);\r\n  buck_converter_w_feedback_initialize();\r\n  noInterrupts();\r\n  configureArduinoARM_M0plus_RP2040_Alarm();\r\n  runModel =\r\n    rtmGetErrorStatus(buck_converter_w_feedback_M) == (NULL)&&\r\n    !rtmGetStopRequested(buck_converter_w_feedback_M);\r\n\r\n#ifndef _MW_ARDUINO_LOOP_\r\n\r\n  interrupts();\r\n\r\n#endif;\r\n\r\n  interrupts();\r\n  while (runModel) {\r\n    stopRequested = !(\r\n                      rtmGetErrorStatus(buck_converter_w_feedback_M) == (NULL)&&\r\n                      !rtmGetStopRequested(buck_converter_w_feedback_M));\r\n    MW_Arduino_Loop();\r\n  }\r\n\r\n  /* Terminate model */\r\n  buck_converter_w_feedback_terminate();\r\n  MW_Arduino_Terminate();\r\n  noInterrupts();\r\n  return 0;\r\n}\r\n"},{"name":"buck_converter_w_feedback.c","type":"source","group":"model","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * buck_converter_w_feedback.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"buck_converter_w_feedback\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Fri Mar  7 16:17:32 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"buck_converter_w_feedback.h\"\r\n#include \"buck_converter_w_feedback_private.h\"\r\n#include \"rtwtypes.h\"\r\n#include <string.h>\r\n#include <math.h>\r\n\r\n/* Block signals (default storage) */\r\nB_buck_converter_w_feedback_T buck_converter_w_feedback_B;\r\n\r\n/* Continuous states */\r\nX_buck_converter_w_feedback_T buck_converter_w_feedback_X;\r\n\r\n/* Disabled State Vector */\r\nXDis_buck_converter_w_feedbac_T buck_converter_w_feedback_XDis;\r\n\r\n/* Block states (default storage) */\r\nDW_buck_converter_w_feedback_T buck_converter_w_feedback_DW;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_buck_converter_w_fee_T buck_converter_w_feedback_M_;\r\nRT_MODEL_buck_converter_w_fee_T *const buck_converter_w_feedback_M =\r\n  &buck_converter_w_feedback_M_;\r\n\r\n/*\r\n * This function updates continuous states using the ODE4 fixed-step\r\n * solver algorithm\r\n */\r\nstatic void rt_ertODEUpdateContinuousStates(RTWSolverInfo *si )\r\n{\r\n  time_T t = rtsiGetT(si);\r\n  time_T tnew = rtsiGetSolverStopTime(si);\r\n  time_T h = rtsiGetStepSize(si);\r\n  real_T *x = rtsiGetContStates(si);\r\n  ODE4_IntgData *id = (ODE4_IntgData *)rtsiGetSolverData(si);\r\n  real_T *y = id->y;\r\n  real_T *f0 = id->f[0];\r\n  real_T *f1 = id->f[1];\r\n  real_T *f2 = id->f[2];\r\n  real_T *f3 = id->f[3];\r\n  real_T temp;\r\n  int_T i;\r\n  int_T nXc = 1;\r\n  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\r\n\r\n  /* Save the state values at time t in y, we'll use x as ynew. */\r\n  (void) memcpy(y, x,\r\n                (uint_T)nXc*sizeof(real_T));\r\n\r\n  /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\r\n  /* f0 = f(t,y) */\r\n  rtsiSetdX(si, f0);\r\n  buck_converter_w_feedback_derivatives();\r\n\r\n  /* f1 = f(t + (h/2), y + (h/2)*f0) */\r\n  temp = 0.5 * h;\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (temp*f0[i]);\r\n  }\r\n\r\n  rtsiSetT(si, t + temp);\r\n  rtsiSetdX(si, f1);\r\n  buck_converter_w_feedback_step();\r\n  buck_converter_w_feedback_derivatives();\r\n\r\n  /* f2 = f(t + (h/2), y + (h/2)*f1) */\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (temp*f1[i]);\r\n  }\r\n\r\n  rtsiSetdX(si, f2);\r\n  buck_converter_w_feedback_step();\r\n  buck_converter_w_feedback_derivatives();\r\n\r\n  /* f3 = f(t + h, y + h*f2) */\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (h*f2[i]);\r\n  }\r\n\r\n  rtsiSetT(si, tnew);\r\n  rtsiSetdX(si, f3);\r\n  buck_converter_w_feedback_step();\r\n  buck_converter_w_feedback_derivatives();\r\n\r\n  /* tnew = t + h\r\n     ynew = y + (h/6)*(f0 + 2*f1 + 2*f2 + 2*f3) */\r\n  temp = h / 6.0;\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + temp*(f0[i] + 2.0*f1[i] + 2.0*f2[i] + f3[i]);\r\n  }\r\n\r\n  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\r\n}\r\n\r\nreal_T rt_roundd_snf(real_T u)\r\n{\r\n  real_T y;\r\n  if (fabs(u) < 4.503599627370496E+15) {\r\n    if (u >= 0.5) {\r\n      y = floor(u + 0.5);\r\n    } else if (u > -0.5) {\r\n      y = u * 0.0;\r\n    } else {\r\n      y = ceil(u - 0.5);\r\n    }\r\n  } else {\r\n    y = u;\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/* Model step function */\r\nvoid buck_converter_w_feedback_step(void)\r\n{\r\n  real_T u0;\r\n  real32_T rtb_Sum;\r\n  uint16_T b_varargout_1;\r\n  uint8_T tmp_0;\r\n  boolean_T tmp;\r\n  if (rtmIsMajorTimeStep(buck_converter_w_feedback_M)) {\r\n    /* set solver stop time */\r\n    if (!(buck_converter_w_feedback_M->Timing.clockTick0+1)) {\r\n      rtsiSetSolverStopTime(&buck_converter_w_feedback_M->solverInfo,\r\n                            ((buck_converter_w_feedback_M->Timing.clockTickH0 +\r\n        1) * buck_converter_w_feedback_M->Timing.stepSize0 * 4294967296.0));\r\n    } else {\r\n      rtsiSetSolverStopTime(&buck_converter_w_feedback_M->solverInfo,\r\n                            ((buck_converter_w_feedback_M->Timing.clockTick0 + 1)\r\n        * buck_converter_w_feedback_M->Timing.stepSize0 +\r\n        buck_converter_w_feedback_M->Timing.clockTickH0 *\r\n        buck_converter_w_feedback_M->Timing.stepSize0 * 4294967296.0));\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  /* Update absolute time of base rate at minor time step */\r\n  if (rtmIsMinorTimeStep(buck_converter_w_feedback_M)) {\r\n    buck_converter_w_feedback_M->Timing.t[0] = rtsiGetT\r\n      (&buck_converter_w_feedback_M->solverInfo);\r\n  }\r\n\r\n  tmp = rtmIsMajorTimeStep(buck_converter_w_feedback_M);\r\n  if (tmp) {\r\n    /* MATLABSystem: '<Root>/Analog Input' */\r\n    buck_converter_w_feedback_DW.obj_l.AnalogInDriverObj.MW_ANALOGIN_HANDLE =\r\n      MW_AnalogIn_GetHandle(28U);\r\n    MW_AnalogInSingle_ReadResult\r\n      (buck_converter_w_feedback_DW.obj_l.AnalogInDriverObj.MW_ANALOGIN_HANDLE,\r\n       &b_varargout_1, MW_ANALOGIN_UINT16);\r\n\r\n    /* Sum: '<S1>/Sum' incorporates:\r\n     *  Constant: '<Root>/Vref'\r\n     *  Gain: '<Root>/Vout D to A'\r\n     *  MATLABSystem: '<Root>/Analog Input'\r\n     * */\r\n    rtb_Sum = buck_converter_w_feedback_P.Vref_Value - (real32_T)((uint32_T)\r\n      buck_converter_w_feedback_P.VoutDtoA_Gain * b_varargout_1) *\r\n      5.96046448E-8F;\r\n\r\n    /* Switch: '<S1>/Switch1' incorporates:\r\n     *  Constant: '<S1>/Constant'\r\n     *  Constant: '<S1>/Constant1'\r\n     */\r\n    if (rtb_Sum > buck_converter_w_feedback_P.Switch1_Threshold_a) {\r\n      u0 = buck_converter_w_feedback_P.Constant_Value;\r\n    } else {\r\n      u0 = buck_converter_w_feedback_P.Constant1_Value;\r\n    }\r\n\r\n    /* MATLABSystem: '<Root>/LED' incorporates:\r\n     *  Switch: '<S1>/Switch1'\r\n     */\r\n    u0 = rt_roundd_snf(u0);\r\n    if (u0 < 256.0) {\r\n      if (u0 >= 0.0) {\r\n        tmp_0 = (uint8_T)u0;\r\n      } else {\r\n        tmp_0 = 0U;\r\n      }\r\n    } else {\r\n      tmp_0 = MAX_uint8_T;\r\n    }\r\n\r\n    writeDigitalPin(25, tmp_0);\r\n\r\n    /* End of MATLABSystem: '<Root>/LED' */\r\n  }\r\n\r\n  /* Switch: '<S3>/Switch' incorporates:\r\n   *  Integrator: '<S1>/Integrator'\r\n   *  Switch: '<S3>/Switch1'\r\n   */\r\n  if (buck_converter_w_feedback_X.Integrator_CSTATE >\r\n      buck_converter_w_feedback_P.Switch_Threshold) {\r\n    /* Switch: '<S3>/Switch' incorporates:\r\n     *  Constant: '<S3>/Constant1'\r\n     */\r\n    buck_converter_w_feedback_B.Switch =\r\n      buck_converter_w_feedback_P.Constant1_Value_k;\r\n  } else if (buck_converter_w_feedback_X.Integrator_CSTATE >\r\n             buck_converter_w_feedback_P.Switch1_Threshold_i) {\r\n    /* Switch: '<S3>/Switch1' incorporates:\r\n     *  Switch: '<S3>/Switch'\r\n     */\r\n    buck_converter_w_feedback_B.Switch =\r\n      buck_converter_w_feedback_X.Integrator_CSTATE;\r\n  } else {\r\n    /* Switch: '<S3>/Switch' incorporates:\r\n     *  Constant: '<S3>/Constant'\r\n     */\r\n    buck_converter_w_feedback_B.Switch =\r\n      buck_converter_w_feedback_P.Constant_Value_f;\r\n  }\r\n\r\n  /* End of Switch: '<S3>/Switch' */\r\n\r\n  /* MATLABSystem: '<Root>/PWM_' */\r\n  buck_converter_w_feedback_DW.obj_h.PWMDriverObj.MW_PWM_HANDLE =\r\n    MW_PWM_GetHandle(16U);\r\n\r\n  /* Gain: '<Root>/duty cycle to digital out' */\r\n  u0 = buck_converter_w_feedback_P.dutycycletodigitalout_Gain *\r\n    buck_converter_w_feedback_B.Switch;\r\n\r\n  /* Start for MATLABSystem: '<Root>/PWM_' */\r\n  if (!(u0 <= 255.0)) {\r\n    u0 = 255.0;\r\n  }\r\n\r\n  if (!(u0 >= 0.0)) {\r\n    u0 = 0.0;\r\n  }\r\n\r\n  /* MATLABSystem: '<Root>/PWM_' */\r\n  MW_PWM_SetDutyCycle\r\n    (buck_converter_w_feedback_DW.obj_h.PWMDriverObj.MW_PWM_HANDLE, u0);\r\n  if (tmp) {\r\n    /* Gain: '<S1>/V time constant' */\r\n    buck_converter_w_feedback_B.Vtimeconstant =\r\n      buck_converter_w_feedback_P.Vtimeconstant_Gain * rtb_Sum;\r\n  }\r\n\r\n  /* Switch: '<S2>/Switch' incorporates:\r\n   *  Integrator: '<S1>/Integrator'\r\n   *  Switch: '<S2>/Switch1'\r\n   */\r\n  if (buck_converter_w_feedback_X.Integrator_CSTATE >\r\n      buck_converter_w_feedback_P.Switch_Threshold_g) {\r\n    /* Switch: '<S2>/Switch' incorporates:\r\n     *  Constant: '<S2>/Constant1'\r\n     */\r\n    buck_converter_w_feedback_B.Switch_n =\r\n      buck_converter_w_feedback_P.Constant1_Value_m;\r\n  } else if (buck_converter_w_feedback_X.Integrator_CSTATE >\r\n             buck_converter_w_feedback_P.Switch1_Threshold) {\r\n    /* Switch: '<S2>/Switch1' incorporates:\r\n     *  Switch: '<S2>/Switch'\r\n     */\r\n    buck_converter_w_feedback_B.Switch_n =\r\n      buck_converter_w_feedback_B.Vtimeconstant;\r\n  } else {\r\n    /* Switch: '<S2>/Switch' incorporates:\r\n     *  Constant: '<S2>/Constant'\r\n     */\r\n    buck_converter_w_feedback_B.Switch_n =\r\n      buck_converter_w_feedback_P.Constant_Value_o;\r\n  }\r\n\r\n  /* End of Switch: '<S2>/Switch' */\r\n  if (rtmIsMajorTimeStep(buck_converter_w_feedback_M)) {\r\n    rt_ertODEUpdateContinuousStates(&buck_converter_w_feedback_M->solverInfo);\r\n\r\n    /* Update absolute time for base rate */\r\n    /* The \"clockTick0\" counts the number of times the code of this task has\r\n     * been executed. The absolute time is the multiplication of \"clockTick0\"\r\n     * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\r\n     * overflow during the application lifespan selected.\r\n     * Timer of this task consists of two 32 bit unsigned integers.\r\n     * The two integers represent the low bits Timing.clockTick0 and the high bits\r\n     * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.\r\n     */\r\n    if (!(++buck_converter_w_feedback_M->Timing.clockTick0)) {\r\n      ++buck_converter_w_feedback_M->Timing.clockTickH0;\r\n    }\r\n\r\n    buck_converter_w_feedback_M->Timing.t[0] = rtsiGetSolverStopTime\r\n      (&buck_converter_w_feedback_M->solverInfo);\r\n\r\n    {\r\n      /* Update absolute timer for sample time: [0.001s, 0.0s] */\r\n      /* The \"clockTick1\" counts the number of times the code of this task has\r\n       * been executed. The resolution of this integer timer is 0.001, which is the step size\r\n       * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\r\n       * application lifespan selected.\r\n       * Timer of this task consists of two 32 bit unsigned integers.\r\n       * The two integers represent the low bits Timing.clockTick1 and the high bits\r\n       * Timing.clockTickH1. When the low bit overflows to 0, the high bits increment.\r\n       */\r\n      buck_converter_w_feedback_M->Timing.clockTick1++;\r\n      if (!buck_converter_w_feedback_M->Timing.clockTick1) {\r\n        buck_converter_w_feedback_M->Timing.clockTickH1++;\r\n      }\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n}\r\n\r\n/* Derivatives for root system: '<Root>' */\r\nvoid buck_converter_w_feedback_derivatives(void)\r\n{\r\n  XDot_buck_converter_w_feedbac_T *_rtXdot;\r\n  _rtXdot = ((XDot_buck_converter_w_feedbac_T *)\r\n             buck_converter_w_feedback_M->derivs);\r\n\r\n  /* Derivatives for Integrator: '<S1>/Integrator' */\r\n  _rtXdot->Integrator_CSTATE = buck_converter_w_feedback_B.Switch_n;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid buck_converter_w_feedback_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize real-time model */\r\n  (void) memset((void *)buck_converter_w_feedback_M, 0,\r\n                sizeof(RT_MODEL_buck_converter_w_fee_T));\r\n\r\n  {\r\n    /* Setup solver object */\r\n    rtsiSetSimTimeStepPtr(&buck_converter_w_feedback_M->solverInfo,\r\n                          &buck_converter_w_feedback_M->Timing.simTimeStep);\r\n    rtsiSetTPtr(&buck_converter_w_feedback_M->solverInfo, &rtmGetTPtr\r\n                (buck_converter_w_feedback_M));\r\n    rtsiSetStepSizePtr(&buck_converter_w_feedback_M->solverInfo,\r\n                       &buck_converter_w_feedback_M->Timing.stepSize0);\r\n    rtsiSetdXPtr(&buck_converter_w_feedback_M->solverInfo,\r\n                 &buck_converter_w_feedback_M->derivs);\r\n    rtsiSetContStatesPtr(&buck_converter_w_feedback_M->solverInfo, (real_T **)\r\n                         &buck_converter_w_feedback_M->contStates);\r\n    rtsiSetNumContStatesPtr(&buck_converter_w_feedback_M->solverInfo,\r\n      &buck_converter_w_feedback_M->Sizes.numContStates);\r\n    rtsiSetNumPeriodicContStatesPtr(&buck_converter_w_feedback_M->solverInfo,\r\n      &buck_converter_w_feedback_M->Sizes.numPeriodicContStates);\r\n    rtsiSetPeriodicContStateIndicesPtr(&buck_converter_w_feedback_M->solverInfo,\r\n      &buck_converter_w_feedback_M->periodicContStateIndices);\r\n    rtsiSetPeriodicContStateRangesPtr(&buck_converter_w_feedback_M->solverInfo,\r\n      &buck_converter_w_feedback_M->periodicContStateRanges);\r\n    rtsiSetContStateDisabledPtr(&buck_converter_w_feedback_M->solverInfo,\r\n      (boolean_T**) &buck_converter_w_feedback_M->contStateDisabled);\r\n    rtsiSetErrorStatusPtr(&buck_converter_w_feedback_M->solverInfo,\r\n                          (&rtmGetErrorStatus(buck_converter_w_feedback_M)));\r\n    rtsiSetRTModelPtr(&buck_converter_w_feedback_M->solverInfo,\r\n                      buck_converter_w_feedback_M);\r\n  }\r\n\r\n  rtsiSetSimTimeStep(&buck_converter_w_feedback_M->solverInfo, MAJOR_TIME_STEP);\r\n  rtsiSetIsMinorTimeStepWithModeChange(&buck_converter_w_feedback_M->solverInfo,\r\n    false);\r\n  rtsiSetIsContModeFrozen(&buck_converter_w_feedback_M->solverInfo, false);\r\n  buck_converter_w_feedback_M->intgData.y = buck_converter_w_feedback_M->odeY;\r\n  buck_converter_w_feedback_M->intgData.f[0] = buck_converter_w_feedback_M->\r\n    odeF[0];\r\n  buck_converter_w_feedback_M->intgData.f[1] = buck_converter_w_feedback_M->\r\n    odeF[1];\r\n  buck_converter_w_feedback_M->intgData.f[2] = buck_converter_w_feedback_M->\r\n    odeF[2];\r\n  buck_converter_w_feedback_M->intgData.f[3] = buck_converter_w_feedback_M->\r\n    odeF[3];\r\n  buck_converter_w_feedback_M->contStates = ((X_buck_converter_w_feedback_T *)\r\n    &buck_converter_w_feedback_X);\r\n  buck_converter_w_feedback_M->contStateDisabled =\r\n    ((XDis_buck_converter_w_feedbac_T *) &buck_converter_w_feedback_XDis);\r\n  buck_converter_w_feedback_M->Timing.tStart = (0.0);\r\n  rtsiSetSolverData(&buck_converter_w_feedback_M->solverInfo, (void *)\r\n                    &buck_converter_w_feedback_M->intgData);\r\n  rtsiSetSolverName(&buck_converter_w_feedback_M->solverInfo,\"ode4\");\r\n  rtmSetTPtr(buck_converter_w_feedback_M,\r\n             &buck_converter_w_feedback_M->Timing.tArray[0]);\r\n  buck_converter_w_feedback_M->Timing.stepSize0 = 0.001;\r\n\r\n  /* block I/O */\r\n  (void) memset(((void *) &buck_converter_w_feedback_B), 0,\r\n                sizeof(B_buck_converter_w_feedback_T));\r\n\r\n  /* states (continuous) */\r\n  {\r\n    (void) memset((void *)&buck_converter_w_feedback_X, 0,\r\n                  sizeof(X_buck_converter_w_feedback_T));\r\n  }\r\n\r\n  /* disabled states */\r\n  {\r\n    (void) memset((void *)&buck_converter_w_feedback_XDis, 0,\r\n                  sizeof(XDis_buck_converter_w_feedbac_T));\r\n  }\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)&buck_converter_w_feedback_DW, 0,\r\n                sizeof(DW_buck_converter_w_feedback_T));\r\n\r\n  /* Start for MATLABSystem: '<Root>/Analog Input' */\r\n  buck_converter_w_feedback_DW.obj_l.matlabCodegenIsDeleted = false;\r\n  buck_converter_w_feedback_DW.objisempty_d = true;\r\n  buck_converter_w_feedback_DW.obj_l.isInitialized = 1;\r\n  buck_converter_w_feedback_DW.obj_l.AnalogInDriverObj.MW_ANALOGIN_HANDLE =\r\n    MW_AnalogInSingle_Open(28U);\r\n  buck_converter_w_feedback_DW.obj_l.isSetupComplete = true;\r\n\r\n  /* Start for MATLABSystem: '<Root>/LED' */\r\n  buck_converter_w_feedback_DW.obj.matlabCodegenIsDeleted = false;\r\n  buck_converter_w_feedback_DW.objisempty_p = true;\r\n  buck_converter_w_feedback_DW.obj.isInitialized = 1;\r\n  digitalIOSetup(25, 1);\r\n  buck_converter_w_feedback_DW.obj.isSetupComplete = true;\r\n\r\n  /* Start for MATLABSystem: '<Root>/PWM_' */\r\n  buck_converter_w_feedback_DW.obj_h.matlabCodegenIsDeleted = false;\r\n  buck_converter_w_feedback_DW.objisempty = true;\r\n  buck_converter_w_feedback_DW.obj_h.isInitialized = 1;\r\n  buck_converter_w_feedback_DW.obj_h.PWMDriverObj.MW_PWM_HANDLE = MW_PWM_Open\r\n    (16U, 0.0, 0.0);\r\n  buck_converter_w_feedback_DW.obj_h.isSetupComplete = true;\r\n\r\n  /* InitializeConditions for Integrator: '<S1>/Integrator' */\r\n  buck_converter_w_feedback_X.Integrator_CSTATE =\r\n    buck_converter_w_feedback_P.Integrator_IC;\r\n}\r\n\r\n/* Model terminate function */\r\nvoid buck_converter_w_feedback_terminate(void)\r\n{\r\n  /* Terminate for MATLABSystem: '<Root>/Analog Input' */\r\n  if (!buck_converter_w_feedback_DW.obj_l.matlabCodegenIsDeleted) {\r\n    buck_converter_w_feedback_DW.obj_l.matlabCodegenIsDeleted = true;\r\n    if ((buck_converter_w_feedback_DW.obj_l.isInitialized == 1) &&\r\n        buck_converter_w_feedback_DW.obj_l.isSetupComplete) {\r\n      buck_converter_w_feedback_DW.obj_l.AnalogInDriverObj.MW_ANALOGIN_HANDLE =\r\n        MW_AnalogIn_GetHandle(28U);\r\n      MW_AnalogIn_Close\r\n        (buck_converter_w_feedback_DW.obj_l.AnalogInDriverObj.MW_ANALOGIN_HANDLE);\r\n    }\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<Root>/Analog Input' */\r\n\r\n  /* Terminate for MATLABSystem: '<Root>/LED' */\r\n  if (!buck_converter_w_feedback_DW.obj.matlabCodegenIsDeleted) {\r\n    buck_converter_w_feedback_DW.obj.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<Root>/LED' */\r\n\r\n  /* Terminate for MATLABSystem: '<Root>/PWM_' */\r\n  if (!buck_converter_w_feedback_DW.obj_h.matlabCodegenIsDeleted) {\r\n    buck_converter_w_feedback_DW.obj_h.matlabCodegenIsDeleted = true;\r\n    if ((buck_converter_w_feedback_DW.obj_h.isInitialized == 1) &&\r\n        buck_converter_w_feedback_DW.obj_h.isSetupComplete) {\r\n      buck_converter_w_feedback_DW.obj_h.PWMDriverObj.MW_PWM_HANDLE =\r\n        MW_PWM_GetHandle(16U);\r\n      MW_PWM_SetDutyCycle\r\n        (buck_converter_w_feedback_DW.obj_h.PWMDriverObj.MW_PWM_HANDLE, 0.0);\r\n      buck_converter_w_feedback_DW.obj_h.PWMDriverObj.MW_PWM_HANDLE =\r\n        MW_PWM_GetHandle(16U);\r\n      MW_PWM_Close(buck_converter_w_feedback_DW.obj_h.PWMDriverObj.MW_PWM_HANDLE);\r\n    }\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<Root>/PWM_' */\r\n}\r\n"},{"name":"buck_converter_w_feedback.h","type":"header","group":"model","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * buck_converter_w_feedback.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"buck_converter_w_feedback\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Fri Mar  7 16:17:32 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef buck_converter_w_feedback_h_\r\n#define buck_converter_w_feedback_h_\r\n#ifndef buck_converter_w_feedback_COMMON_INCLUDES_\r\n#define buck_converter_w_feedback_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#include \"MW_AnalogIn.h\"\r\n#include \"MW_arduino_digitalio.h\"\r\n#include \"MW_PWM.h\"\r\n#endif                          /* buck_converter_w_feedback_COMMON_INCLUDES_ */\r\n\r\n#include \"buck_converter_w_feedback_types.h\"\r\n#include <string.h>\r\n#include <stddef.h>\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetContStateDisabled\r\n#define rtmGetContStateDisabled(rtm)   ((rtm)->contStateDisabled)\r\n#endif\r\n\r\n#ifndef rtmSetContStateDisabled\r\n#define rtmSetContStateDisabled(rtm, val) ((rtm)->contStateDisabled = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContStates\r\n#define rtmGetContStates(rtm)          ((rtm)->contStates)\r\n#endif\r\n\r\n#ifndef rtmSetContStates\r\n#define rtmSetContStates(rtm, val)     ((rtm)->contStates = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\r\n#endif\r\n\r\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\r\n#endif\r\n\r\n#ifndef rtmGetDerivCacheNeedsReset\r\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetDerivCacheNeedsReset\r\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetIntgData\r\n#define rtmGetIntgData(rtm)            ((rtm)->intgData)\r\n#endif\r\n\r\n#ifndef rtmSetIntgData\r\n#define rtmSetIntgData(rtm, val)       ((rtm)->intgData = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeF\r\n#define rtmGetOdeF(rtm)                ((rtm)->odeF)\r\n#endif\r\n\r\n#ifndef rtmSetOdeF\r\n#define rtmSetOdeF(rtm, val)           ((rtm)->odeF = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeY\r\n#define rtmGetOdeY(rtm)                ((rtm)->odeY)\r\n#endif\r\n\r\n#ifndef rtmSetOdeY\r\n#define rtmSetOdeY(rtm, val)           ((rtm)->odeY = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateIndices\r\n#define rtmGetPeriodicContStateIndices(rtm) ((rtm)->periodicContStateIndices)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateIndices\r\n#define rtmSetPeriodicContStateIndices(rtm, val) ((rtm)->periodicContStateIndices = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateRanges\r\n#define rtmGetPeriodicContStateRanges(rtm) ((rtm)->periodicContStateRanges)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateRanges\r\n#define rtmSetPeriodicContStateRanges(rtm, val) ((rtm)->periodicContStateRanges = (val))\r\n#endif\r\n\r\n#ifndef rtmGetZCCacheNeedsReset\r\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetZCCacheNeedsReset\r\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetdX\r\n#define rtmGetdX(rtm)                  ((rtm)->derivs)\r\n#endif\r\n\r\n#ifndef rtmSetdX\r\n#define rtmSetdX(rtm, val)             ((rtm)->derivs = (val))\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\r\n#endif\r\n\r\n#ifndef rtmSetStopRequested\r\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequestedPtr\r\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\r\n#endif\r\n\r\n#ifndef rtmGetT\r\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\r\n#endif\r\n\r\n#ifndef rtmGetTPtr\r\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\r\n#endif\r\n\r\n#ifndef rtmGetTStart\r\n#define rtmGetTStart(rtm)              ((rtm)->Timing.tStart)\r\n#endif\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T Switch;                       /* '<S3>/Switch' */\r\n  real_T Switch_n;                     /* '<S2>/Switch' */\r\n  real32_T Vtimeconstant;              /* '<S1>/V time constant' */\r\n} B_buck_converter_w_feedback_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  codertarget_arduinobase_block_T obj; /* '<Root>/LED' */\r\n  codertarget_arduinobase_inter_T obj_l;/* '<Root>/Analog Input' */\r\n  codertarget_arduinobase_int_i_T obj_h;/* '<Root>/PWM_' */\r\n  struct {\r\n    void *LoggedData;\r\n  } Scope_PWORK;                       /* '<Root>/Scope' */\r\n\r\n  boolean_T objisempty;                /* '<Root>/PWM_' */\r\n  boolean_T objisempty_p;              /* '<Root>/LED' */\r\n  boolean_T objisempty_d;              /* '<Root>/Analog Input' */\r\n} DW_buck_converter_w_feedback_T;\r\n\r\n/* Continuous states (default storage) */\r\ntypedef struct {\r\n  real_T Integrator_CSTATE;            /* '<S1>/Integrator' */\r\n} X_buck_converter_w_feedback_T;\r\n\r\n/* State derivatives (default storage) */\r\ntypedef struct {\r\n  real_T Integrator_CSTATE;            /* '<S1>/Integrator' */\r\n} XDot_buck_converter_w_feedbac_T;\r\n\r\n/* State disabled  */\r\ntypedef struct {\r\n  boolean_T Integrator_CSTATE;         /* '<S1>/Integrator' */\r\n} XDis_buck_converter_w_feedbac_T;\r\n\r\n#ifndef ODE4_INTG\r\n#define ODE4_INTG\r\n\r\n/* ODE4 Integration Data */\r\ntypedef struct {\r\n  real_T *y;                           /* output */\r\n  real_T *f[4];                        /* derivatives */\r\n} ODE4_IntgData;\r\n\r\n#endif\r\n\r\n/* Parameters (default storage) */\r\nstruct P_buck_converter_w_feedback_T_ {\r\n  real_T Constant_Value;               /* Expression: 1\r\n                                        * Referenced by: '<S1>/Constant'\r\n                                        */\r\n  real_T Constant1_Value;              /* Expression: 0\r\n                                        * Referenced by: '<S1>/Constant1'\r\n                                        */\r\n  real_T Switch1_Threshold;            /* Expression: 0\r\n                                        * Referenced by: '<S2>/Switch1'\r\n                                        */\r\n  real_T Switch1_Threshold_i;          /* Expression: 0\r\n                                        * Referenced by: '<S3>/Switch1'\r\n                                        */\r\n  real_T Constant1_Value_k;            /* Expression: 1\r\n                                        * Referenced by: '<S3>/Constant1'\r\n                                        */\r\n  real_T Integrator_IC;                /* Expression: 0.5\r\n                                        * Referenced by: '<S1>/Integrator'\r\n                                        */\r\n  real_T Constant_Value_f;             /* Expression: 0\r\n                                        * Referenced by: '<S3>/Constant'\r\n                                        */\r\n  real_T Switch_Threshold;             /* Expression: 1\r\n                                        * Referenced by: '<S3>/Switch'\r\n                                        */\r\n  real_T dutycycletodigitalout_Gain;   /* Expression: 255\r\n                                        * Referenced by: '<Root>/duty cycle to digital out'\r\n                                        */\r\n  real_T Constant_Value_o;             /* Expression: 0\r\n                                        * Referenced by: '<S2>/Constant'\r\n                                        */\r\n  real_T Constant1_Value_m;            /* Expression: 1\r\n                                        * Referenced by: '<S2>/Constant1'\r\n                                        */\r\n  real_T Switch_Threshold_g;           /* Expression: 1\r\n                                        * Referenced by: '<S2>/Switch'\r\n                                        */\r\n  real32_T Vref_Value;                 /* Computed Parameter: Vref_Value\r\n                                        * Referenced by: '<Root>/Vref'\r\n                                        */\r\n  real32_T Switch1_Threshold_a;       /* Computed Parameter: Switch1_Threshold_a\r\n                                       * Referenced by: '<S1>/Switch1'\r\n                                       */\r\n  real32_T Vtimeconstant_Gain;         /* Computed Parameter: Vtimeconstant_Gain\r\n                                        * Referenced by: '<S1>/V time constant'\r\n                                        */\r\n  uint16_T VoutDtoA_Gain;              /* Computed Parameter: VoutDtoA_Gain\r\n                                        * Referenced by: '<Root>/Vout D to A'\r\n                                        */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_buck_converter_w_feed_T {\r\n  const char_T *errorStatus;\r\n  RTWSolverInfo solverInfo;\r\n  X_buck_converter_w_feedback_T *contStates;\r\n  int_T *periodicContStateIndices;\r\n  real_T *periodicContStateRanges;\r\n  real_T *derivs;\r\n  XDis_buck_converter_w_feedbac_T *contStateDisabled;\r\n  boolean_T zCCacheNeedsReset;\r\n  boolean_T derivCacheNeedsReset;\r\n  boolean_T CTOutputIncnstWithState;\r\n  real_T odeY[1];\r\n  real_T odeF[4][1];\r\n  ODE4_IntgData intgData;\r\n\r\n  /*\r\n   * Sizes:\r\n   * The following substructure contains sizes information\r\n   * for many of the model attributes such as inputs, outputs,\r\n   * dwork, sample times, etc.\r\n   */\r\n  struct {\r\n    int_T numContStates;\r\n    int_T numPeriodicContStates;\r\n    int_T numSampTimes;\r\n  } Sizes;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    uint32_T clockTick0;\r\n    uint32_T clockTickH0;\r\n    time_T stepSize0;\r\n    uint32_T clockTick1;\r\n    uint32_T clockTickH1;\r\n    time_T tStart;\r\n    SimTimeStep simTimeStep;\r\n    boolean_T stopRequestedFlag;\r\n    time_T *t;\r\n    time_T tArray[2];\r\n  } Timing;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P_buck_converter_w_feedback_T buck_converter_w_feedback_P;\r\n\r\n/* Block signals (default storage) */\r\nextern B_buck_converter_w_feedback_T buck_converter_w_feedback_B;\r\n\r\n/* Continuous states (default storage) */\r\nextern X_buck_converter_w_feedback_T buck_converter_w_feedback_X;\r\n\r\n/* Disabled states (default storage) */\r\nextern XDis_buck_converter_w_feedbac_T buck_converter_w_feedback_XDis;\r\n\r\n/* Block states (default storage) */\r\nextern DW_buck_converter_w_feedback_T buck_converter_w_feedback_DW;\r\n\r\n/* Model entry point functions */\r\nextern void buck_converter_w_feedback_initialize(void);\r\nextern void buck_converter_w_feedback_step(void);\r\nextern void buck_converter_w_feedback_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_buck_converter_w_fee_T *const buck_converter_w_feedback_M;\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S1>/Display' : Unused code path elimination\r\n * Block '<S1>/Display1' : Unused code path elimination\r\n * Block '<S1>/Display2' : Unused code path elimination\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'buck_converter_w_feedback'\r\n * '<S1>'   : 'buck_converter_w_feedback/C'\r\n * '<S2>'   : 'buck_converter_w_feedback/C/pass 0-1 (in)'\r\n * '<S3>'   : 'buck_converter_w_feedback/C/pass 0-1 (out)'\r\n */\r\n#endif                                 /* buck_converter_w_feedback_h_ */\r\n"},{"name":"buck_converter_w_feedback_private.h","type":"header","group":"model","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * buck_converter_w_feedback_private.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"buck_converter_w_feedback\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Fri Mar  7 16:17:32 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef buck_converter_w_feedback_private_h_\r\n#define buck_converter_w_feedback_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n#include \"buck_converter_w_feedback_types.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n\r\n/* Private macros used by the generated code to access rtModel */\r\n#ifndef rtmIsMajorTimeStep\r\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmIsMinorTimeStep\r\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmSetTPtr\r\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\r\n#endif\r\n\r\n#ifndef UCHAR_MAX\r\n#include <limits.h>\r\n#endif\r\n\r\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\r\n#error Code was generated for compiler with different sized uchar/char. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized ushort/short. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( UINT_MAX != (0xFFFFFFFFU) ) || ( INT_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized uint/int. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( ULONG_MAX != (0xFFFFFFFFU) ) || ( LONG_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized ulong/long. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\nextern real_T rt_roundd_snf(real_T u);\r\n\r\n/* private model entry point functions */\r\nextern void buck_converter_w_feedback_derivatives(void);\r\n\r\n#endif                                /* buck_converter_w_feedback_private_h_ */\r\n"},{"name":"buck_converter_w_feedback_types.h","type":"header","group":"model","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * buck_converter_w_feedback_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"buck_converter_w_feedback\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Fri Mar  7 16:17:32 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef buck_converter_w_feedback_types_h_\r\n#define buck_converter_w_feedback_types_h_\r\n#include \"MW_SVD.h\"\r\n#include \"rtwtypes.h\"\r\n\r\n/* Custom Type definition for MATLABSystem: '<Root>/PWM_' */\r\n#include \"MW_SVD.h\"\r\n#ifndef struct_tag_pMPPJgn69ckPBhypf3vQzD\r\n#define struct_tag_pMPPJgn69ckPBhypf3vQzD\r\n\r\nstruct tag_pMPPJgn69ckPBhypf3vQzD\r\n{\r\n  MW_Handle_Type MW_ANALOGIN_HANDLE;\r\n};\r\n\r\n#endif                                 /* struct_tag_pMPPJgn69ckPBhypf3vQzD */\r\n\r\n#ifndef typedef_e_arduinodriver_ArduinoAnalog_T\r\n#define typedef_e_arduinodriver_ArduinoAnalog_T\r\n\r\ntypedef struct tag_pMPPJgn69ckPBhypf3vQzD e_arduinodriver_ArduinoAnalog_T;\r\n\r\n#endif                             /* typedef_e_arduinodriver_ArduinoAnalog_T */\r\n\r\n#ifndef struct_tag_FIY6N64L77TlG9jHBRqBuB\r\n#define struct_tag_FIY6N64L77TlG9jHBRqBuB\r\n\r\nstruct tag_FIY6N64L77TlG9jHBRqBuB\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  e_arduinodriver_ArduinoAnalog_T AnalogInDriverObj;\r\n};\r\n\r\n#endif                                 /* struct_tag_FIY6N64L77TlG9jHBRqBuB */\r\n\r\n#ifndef typedef_codertarget_arduinobase_inter_T\r\n#define typedef_codertarget_arduinobase_inter_T\r\n\r\ntypedef struct tag_FIY6N64L77TlG9jHBRqBuB codertarget_arduinobase_inter_T;\r\n\r\n#endif                             /* typedef_codertarget_arduinobase_inter_T */\r\n\r\n#ifndef struct_tag_um27AmhtbslH2i5VSgy0RG\r\n#define struct_tag_um27AmhtbslH2i5VSgy0RG\r\n\r\nstruct tag_um27AmhtbslH2i5VSgy0RG\r\n{\r\n  int32_T __dummy;\r\n};\r\n\r\n#endif                                 /* struct_tag_um27AmhtbslH2i5VSgy0RG */\r\n\r\n#ifndef typedef_b_arduinodriver_ArduinoDigita_T\r\n#define typedef_b_arduinodriver_ArduinoDigita_T\r\n\r\ntypedef struct tag_um27AmhtbslH2i5VSgy0RG b_arduinodriver_ArduinoDigita_T;\r\n\r\n#endif                             /* typedef_b_arduinodriver_ArduinoDigita_T */\r\n\r\n#ifndef struct_tag_lLXm9RMdC1wJGOFiPwVXeD\r\n#define struct_tag_lLXm9RMdC1wJGOFiPwVXeD\r\n\r\nstruct tag_lLXm9RMdC1wJGOFiPwVXeD\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  b_arduinodriver_ArduinoDigita_T DigitalIODriverObj;\r\n};\r\n\r\n#endif                                 /* struct_tag_lLXm9RMdC1wJGOFiPwVXeD */\r\n\r\n#ifndef typedef_codertarget_arduinobase_block_T\r\n#define typedef_codertarget_arduinobase_block_T\r\n\r\ntypedef struct tag_lLXm9RMdC1wJGOFiPwVXeD codertarget_arduinobase_block_T;\r\n\r\n#endif                             /* typedef_codertarget_arduinobase_block_T */\r\n\r\n#ifndef struct_tag_7VFuPw0vSNrn5pRgG8Mc4C\r\n#define struct_tag_7VFuPw0vSNrn5pRgG8Mc4C\r\n\r\nstruct tag_7VFuPw0vSNrn5pRgG8Mc4C\r\n{\r\n  MW_Handle_Type MW_PWM_HANDLE;\r\n};\r\n\r\n#endif                                 /* struct_tag_7VFuPw0vSNrn5pRgG8Mc4C */\r\n\r\n#ifndef typedef_e_matlabshared_ioclient_perip_T\r\n#define typedef_e_matlabshared_ioclient_perip_T\r\n\r\ntypedef struct tag_7VFuPw0vSNrn5pRgG8Mc4C e_matlabshared_ioclient_perip_T;\r\n\r\n#endif                             /* typedef_e_matlabshared_ioclient_perip_T */\r\n\r\n#ifndef struct_tag_RWocY1aAVmuibq0rYX5t0G\r\n#define struct_tag_RWocY1aAVmuibq0rYX5t0G\r\n\r\nstruct tag_RWocY1aAVmuibq0rYX5t0G\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  e_matlabshared_ioclient_perip_T PWMDriverObj;\r\n};\r\n\r\n#endif                                 /* struct_tag_RWocY1aAVmuibq0rYX5t0G */\r\n\r\n#ifndef typedef_codertarget_arduinobase_int_i_T\r\n#define typedef_codertarget_arduinobase_int_i_T\r\n\r\ntypedef struct tag_RWocY1aAVmuibq0rYX5t0G codertarget_arduinobase_int_i_T;\r\n\r\n#endif                             /* typedef_codertarget_arduinobase_int_i_T */\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_buck_converter_w_feedback_T_ P_buck_converter_w_feedback_T;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_buck_converter_w_feed_T RT_MODEL_buck_converter_w_fee_T;\r\n\r\n#endif                                 /* buck_converter_w_feedback_types_h_ */\r\n"},{"name":"buck_converter_w_feedback_data.c","type":"source","group":"data","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * buck_converter_w_feedback_data.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"buck_converter_w_feedback\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Fri Mar  7 16:17:32 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"buck_converter_w_feedback.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP_buck_converter_w_feedback_T buck_converter_w_feedback_P = {\r\n  /* Expression: 1\r\n   * Referenced by: '<S1>/Constant'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S1>/Constant1'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S2>/Switch1'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S3>/Switch1'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S3>/Constant1'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 0.5\r\n   * Referenced by: '<S1>/Integrator'\r\n   */\r\n  0.5,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S3>/Constant'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S3>/Switch'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 255\r\n   * Referenced by: '<Root>/duty cycle to digital out'\r\n   */\r\n  255.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S2>/Constant'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S2>/Constant1'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S2>/Switch'\r\n   */\r\n  1.0,\r\n\r\n  /* Computed Parameter: Vref_Value\r\n   * Referenced by: '<Root>/Vref'\r\n   */\r\n  5.0F,\r\n\r\n  /* Computed Parameter: Switch1_Threshold_a\r\n   * Referenced by: '<S1>/Switch1'\r\n   */\r\n  0.0F,\r\n\r\n  /* Computed Parameter: Vtimeconstant_Gain\r\n   * Referenced by: '<S1>/V time constant'\r\n   */\r\n  0.5F,\r\n\r\n  /* Computed Parameter: VoutDtoA_Gain\r\n   * Referenced by: '<Root>/Vout D to A'\r\n   */\r\n  63579U\r\n};\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * multiword_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"buck_converter_w_feedback\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Fri Mar  7 16:17:32 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long int long_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint32_T chunks[2];\r\n} int64m_T;\r\n\r\ntypedef struct {\r\n  int64m_T re;\r\n  int64m_T im;\r\n} cint64m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[2];\r\n} uint64m_T;\r\n\r\ntypedef struct {\r\n  uint64m_T re;\r\n  uint64m_T im;\r\n} cuint64m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[3];\r\n} int96m_T;\r\n\r\ntypedef struct {\r\n  int96m_T re;\r\n  int96m_T im;\r\n} cint96m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[3];\r\n} uint96m_T;\r\n\r\ntypedef struct {\r\n  uint96m_T re;\r\n  uint96m_T im;\r\n} cuint96m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[4];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[4];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[5];\r\n} int160m_T;\r\n\r\ntypedef struct {\r\n  int160m_T re;\r\n  int160m_T im;\r\n} cint160m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[5];\r\n} uint160m_T;\r\n\r\ntypedef struct {\r\n  uint160m_T re;\r\n  uint160m_T im;\r\n} cuint160m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[6];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[6];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[7];\r\n} int224m_T;\r\n\r\ntypedef struct {\r\n  int224m_T re;\r\n  int224m_T im;\r\n} cint224m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[7];\r\n} uint224m_T;\r\n\r\ntypedef struct {\r\n  uint224m_T re;\r\n  uint224m_T im;\r\n} cuint224m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[8];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[8];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"buck_converter_w_feedback\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Fri Mar  7 16:17:32 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#include \"tmwtypes.h\"\r\n#ifndef POINTER_T\r\n#define POINTER_T\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * rtmodel.h\r\n *\r\n * Code generation for Simulink model \"buck_converter_w_feedback\".\r\n *\r\n * Simulink Coder version                : 24.2 (R2024b) 21-Jun-2024\r\n * C source code generated on : Fri Mar  7 16:17:32 2025\r\n *\r\n * Note that the generated code is not dependent on this header file.\r\n * The file is used in cojuction with the automatic build procedure.\r\n * It is included by the sample main executable harness\r\n * MATLAB/rtw/c/src/common/rt_main.c.\r\n *\r\n */\r\n\r\n#ifndef rtmodel_h_\r\n#define rtmodel_h_\r\n#include \"buck_converter_w_feedback.h\"\r\n#endif                                 /* rtmodel_h_ */\r\n"},{"name":"ArduinoPinHandleMap.cpp","type":"source","group":"legacy","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"#include \"rtwtypes.h\"\n\n#define ANALOG_MODULES_MAX 70  /* For Mega and Due. Other boards have less number of Modules */\n#define PWM_MODULES_MAX 70  /* For Mega and Due. Other boards have less number of Modules */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    \ntypedef uint8_T PeripheralHandleMapType;\nPeripheralHandleMapType analogPinHandleMap[(ANALOG_MODULES_MAX/8)+1] = {0};\nPeripheralHandleMapType PWMPinHandleMap[(PWM_MODULES_MAX/8)+1] = {0};\n\n#ifdef __cplusplus\n}\n#endif\n"},{"name":"MW_AnalogInput.cpp","type":"source","group":"legacy","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2017-2024 The MathWorks, Inc. */\n\n#include \"MW_AnalogIn.h\"\n\n#if !(( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) ))\n#include \"Arduino.h\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    \n#define ANALOG_MODULES_MAX 70  /* For Mega and Due. Other boards have less number of Modules */\n    \n    typedef uint8_T PeripheralHandleMapType;\n    extern PeripheralHandleMapType analogPinHandleMap[];    /* The array is defined in ArduinoPinHandleMap.cpp */\n    \n    void setHandle(uint32_T Pin, MW_Handle_Type handle);\n    \n    /* Create AnalogIn group with Channels and Conversion time */\n    MW_Handle_Type MW_AnalogInSingle_Open(uint32_T Pin)\n    {\n#if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n        /* This will be run in Rapid Accelerator Mode */\n        return NULL;\n#else\n        if (Pin < A0)\n        {\n            pinMode(Pin+A0, INPUT);\n        }\n        else{\n            pinMode(Pin, INPUT);\n        }\n        /* handle is stored as Pin+1 because, to reset the handle of a pin, 0 is passed as handle. Otherwise it will create confusion for Pin number 0. */\n        setHandle(Pin, (MW_Handle_Type)(Pin+1));\n        return (MW_Handle_Type)(Pin+1);\n#endif\n        \n    }\n    \n    /* Select trigger source for AnalogIn group to start conversion */\n    void MW_AnalogIn_SetTriggerSource(MW_Handle_Type AnalogInHandle, MW_AnalogIn_TriggerSource_Type TriggerType, uint32_T TriggerValue)\n    {\n        (void)AnalogInHandle;\n        (void)TriggerType;\n        (void)TriggerValue;\n    }\n    \n    /* Enable Conversion complete notification */\n    void MW_AnalogIn_EnableNotification(MW_Handle_Type AnalogInHandle)\n    {\n        (void)AnalogInHandle;\n    }\n    \n    /* Disable notifications */\n    void MW_AnalogIn_DisableNotification(MW_Handle_Type AnalogInHandle)\n    {\n        (void)AnalogInHandle;\n    }\n    \n    /* Enable continuous conversion */\n    void MW_AnalogIn_EnableContConversion(MW_Handle_Type AnalogInHandle)\n    {\n        (void)AnalogInHandle;\n    }\n    \n    /* Set channel conversion priority */\n    void MW_AnalogIn_SetChannelConvRank(MW_Handle_Type AnalogInHandle, uint32_T Channel, uint32_T Rank)\n    {\n        (void)AnalogInHandle;\n        (void)Channel;\n        (void)Rank;\n    }\n    \n    /* Get status of AnalogIn conversion group */\n    MW_AnalogIn_Status_Type MW_AnalogIn_GetStatus(MW_Handle_Type AnalogInHandle)\n    {\n        return MW_ANALOGIN_CONVERSION_COMPLETE;\n    }\n    \n    /* Read channel conversion result */\n    void MW_AnalogInSingle_ReadResult(MW_Handle_Type AnalogInHandle, void * Result_ptr, MW_AnalogIn_ResultDataType_Type ResultDataType)\n    {\n#if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n        /* This will be run in Rapid Accelerator Mode */\n        return;\n#else\n        uint8_T pin;\n        /* If a non zero handle is passed then read the analog input. Otherwise return 0. This\n     is useful for MATLAB codegen is the user tries to read without configuring. In Simulink\n     this situation should never arise*/\n        if(*((uint8_T*)(&AnalogInHandle)))\n        {\n            /* The handle of a Pin is stored as (Pin+1) */\n            pin = *((uint8_T*)(&AnalogInHandle)) - 1;\n            /*Use 12-bit read resolution for Due, MKR1000, BLE sense, RP2040 */\n#if defined(ARDUINO_ARM) || defined(ARDUINO_ARDUINO_NANO33BLE) || defined(ARDUINO_NANO_RP2040_CONNECT) || defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO) || defined(ARDUINO_ARCH_RENESAS_UNO)\n            analogReadResolution(12);\n#endif\n            int sensorValue = analogRead(pin);\n            *(uint16_T *)Result_ptr = sensorValue;\n        }\n        else{\n            *(uint16_T *)Result_ptr = 0;\n        }\n#endif\n    }\n    \n    /* Start conversion */\n    void MW_AnalogIn_Start(MW_Handle_Type AnalogInHandle)\n    {\n        (void)AnalogInHandle;\n    }\n    \n    /* Stop conversion */\n    void MW_AnalogIn_Stop(MW_Handle_Type AnalogInHandle)\n    {\n        (void)AnalogInHandle;\n    }\n    \n    /* De-initialise */\n    void MW_AnalogIn_Close(MW_Handle_Type AnalogInHandle)\n    {\n#if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n        return;\n#else\n        /* If the analog handle is 0 then do nothing. */\n        if(*((uint8_T*)(&AnalogInHandle)))\n        {\n            uint8_T pin = 0;\n            /* The handle of a Pin is stored as (Pin+1) */\n            pin = *((uint8_T*)(&AnalogInHandle)) - 1;\n            /* Reset the handle for that particular pin */\n            setHandle(pin, (MW_Handle_Type)0);\n        }\n        (void)AnalogInHandle;\n#endif\n    }\n    \n    MW_Handle_Type MW_AnalogIn_GetHandle(uint32_T Pin)\n    {\n#if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n        return NULL;\n#else\n        uint16_T ByteNo=0, handleValue=0;\n        \n        uint8_T BitPositionNo=0;\n        \n        ByteNo = Pin/8;\n        BitPositionNo = Pin%8;\n        \n        handleValue = analogPinHandleMap[ByteNo] & (PeripheralHandleMapType)(1<<BitPositionNo);\n        \n        if(handleValue)\n        {\n            /*\n             * Returns the value of the module if the pin is opened earlier\n             */\n            /* What will happen if Pin value is 0 itself? */\n            handleValue = Pin+1;\n            /*\n             * This allows to differentiate between pin zero and a Null condition\n             *\n             * Another option - return true, and then remove the decrement in the SVD of all functions in Arduino\n             */\n        }\n        else\n        {\n            handleValue = 0;\n        }\n        return (MW_Handle_Type)handleValue;\n#endif\n    }\n    \n    void setHandle(uint32_T module, MW_Handle_Type handle)\n    {\n#if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n        return;\n#else\n        /*\n    Assumes pin number from count zero\n         */\n        uint16_T ByteNo=0;\n        uint8_T BitPositionNo=0;\n        PeripheralHandleMapType tempVar=0;\n        /*\n         * Integer division rounds off to value providing the abs byte no\n         */\n        ByteNo = module/8;\n        BitPositionNo = module%8;\n        \n        tempVar = (1<<BitPositionNo);\n        /*\n         * The assumption is module number is the handle,\n         * but when handle is Null, reset the handle\n         */\n        if(!handle)\n        {\n            /*reset the handle*/\n            tempVar = ~tempVar;\n            analogPinHandleMap[ByteNo] = analogPinHandleMap[ByteNo] & tempVar;\n        }\n        else\n        {\n            /*set the handle*/\n            analogPinHandleMap[ByteNo] = analogPinHandleMap[ByteNo] | tempVar;\n        }\n#endif\n    }\n    \n#ifdef __cplusplus\n}\n#endif\n"},{"name":"MW_ArduinoHWInit.cpp","type":"source","group":"legacy","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\target\\supportpackages\\arduinotarget\\src","tag":"","groupDisplay":"Other files","code":"/* Arduino AVR Bareboard scheduler\n*\n* Copyright 2014-2024 The MathWorks, Inc.\n*/\n\n#include \"Arduino.h\"\n#include \"io_wrappers.h\"\n#if defined(ARDUINO_ARM_CORTEX_M0_PLUS)\n#include \"arduinoARM_M0plusScheduler.h\"\n#elif defined(ARDUINO_ARM_CORTEX_M3)\n#include \"arduinoARMScheduler.h\"\n#include \"watchdog.h\"\n#else\n#include \"arduinoAVRScheduler.h\"\n#endif\n\n#if (defined(ARDUINO_ARCH_RENESAS_UNO))\n#include \"MW_ArduinoUnoR4Wifi.h\"\n#endif\n\n#if defined(ESP_PLATFORM)\n#include \"esp_wpa2.h\" //wpa2 library for connections to Enterprise networks\n#endif\n\n#ifdef _RTT_NUMI2C_\n#include \"MW_arduinoI2C.h\"\n#endif\n\n#if defined(ARDUINO_ARDUINO_NANO33BLE)\n#include <USB/PluggableUSBSerial.h> // for PluggableUSBD\n#include \"MW_PWM_NANO33BLE.h\"\n#endif\n\n#if defined(ARDUINO_NANO_RP2040_CONNECT)\n#include <USB/PluggableUSBSerial.h>\n#include \"double_tap_usb_boot.cpp\" // to force double tap detection\n#endif\n\n#if (defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO))\n#include \"RP2040USB.h\"\n#include \"pico_bootsel_via_double_reset.c\" // to force double tap detection\n#include <pico/stdlib.h>\n// Weak empty variant initialization. May be redefined by variant files.\nvoid initVariant() __attribute__((weak));\nvoid initVariant() { }\n#endif\n\n#if (defined(MW_ARDUINO_OV2640CSPIN)) || (defined(_RTT_SPI_SSPIN_)) || (defined(_RTT_DUE_SPI_SSPIN4_)) || (defined(_RTT_DUE_SPI_SSPIN10_)) || (defined(_RTT_DUE_SPI_SSPIN52_))\n#include \"MW_SPIwriteRead.h\"\n#endif\n\n#if (defined(_RTT_RS485_INUSE_))\n#include \"ArduinoRS485.h\"\n#endif\n\n#if (defined(_RTT_MODBUS_MASTER_)) || (defined(_RTT_MODBUS_SLAVE_))\n#include \"ArduinoModbus.h\"\n#endif\n\n#ifdef NANO_MOTOR_CARRIER\n#include <Wire.h>\n#define PMIC_ADDRESS  0x6B\n#define PMIC_REG00    0x00\n#define PMIC_REG01    0x01\n#define PMIC_REG02    0x02\n#define PMIC_REG04    0x04\n#define PMIC_REG05    0x05\nvoid MW_EnableNanoCarrierBatteryCharging(void);\n#endif\n\n// Wifi init routines\n#include <inttypes.h>\n#if (defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)) || (defined(_RTT_WIFI_UDP_) && (_RTT_WIFI_UDP_ != 0)) || (defined(_RTT_WIFI_TCP_) && (_RTT_WIFI_TCP_ != 0))|| defined(_RTT_THINGSPEAK_WIFI_) || defined(_RTT_WEBSOCKET_PORT_) || defined(_RTT_MQTT_WIFI_) || defined(_RTT_HTTP_CLIENT_)\n#if defined(ARDUINO_WIFI_LIB_101)\n#include <WiFi101.h>\n#elif defined(ARDUINO_WIFI_LIB_NINA)\n#include <WiFiNINA.h>\n#elif defined(ARDUINO_UNOR4_WIFI)\n#include <WiFiS3.h>\n#else\n#include <WiFi.h>\n#endif\n#include <SPI.h>\n\n/*#define that helps to stringify build flags\n//Double evaluation is needed so that the double quotes can be derived out\n//of the build flag and can be assigned to a character array */\n#define RTT_StringifyBuildFlag(x) RTT_StringParamExpanded(x)\n#define RTT_StringParamExpanded(x)  #x\n\n#if (_RTT_DISABLE_Wifi_DHCP_ == 1)\nIPAddress wifiLocalIpAddress(_RTT_WIFI_Local_IP1, _RTT_WIFI_Local_IP2, _RTT_WIFI_Local_IP3, _RTT_WIFI_Local_IP4);\n#endif\n\n#if (_RTT_DISABLE_Wifi_DHCP_ == 2)\nIPAddress wifiLocalIpAddress(_RTT_WIFI_Local_IP1, _RTT_WIFI_Local_IP2, _RTT_WIFI_Local_IP3, _RTT_WIFI_Local_IP4);\nIPAddress wifiGatewayAddress(_RTT_WIFI_Gateway_IP1, _RTT_WIFI_Gateway_IP2, _RTT_WIFI_Gateway_IP3, _RTT_WIFI_Gateway_IP4);\nIPAddress wifiSubnetMask(_RTT_WIFI_Subnet_IP1, _RTT_WIFI_Subnet_IP2, _RTT_WIFI_Subnet_IP3, _RTT_WIFI_Subnet_IP4);\nIPAddress wifiDNSAddress(_RTT_WIFI_DNS_IP1, _RTT_WIFI_DNS_IP2, _RTT_WIFI_DNS_IP3, _RTT_WIFI_DNS_IP4);\n#endif\n\n#if defined ESP_PLATFORM || defined(ARDUINO_UNOR4_WIFI)\nIPAddress wifigateway(_RTT_WIFI_Local_IP1, _RTT_WIFI_Local_IP2, _RTT_WIFI_Local_IP3, uint8_t(1));\nIPAddress subnet(uint8_t(255),uint8_t(255),uint8_t(255),uint8_t(0));\nIPAddress dns1 = (uint32_t)0x00000000;\nIPAddress dns2 = (uint32_t)0x00000000;\n#endif\n\nchar ssid[] = RTT_StringifyBuildFlag(_RTT_WIFI_SSID);\nint configureSuccess = WL_IDLE_STATUS;\nint trialcount;\n\n#ifdef _RTT_WIFI_WEP\nchar key[] = RTT_StringifyBuildFlag(_RTT_WIFI_KEY);\nint keyIndex = _RTT_WIFI_KEY_INDEX;\n#endif //_RTT_WIFI_WEP\n\n#ifdef _RTT_WIFI_WPA\nchar wpapass[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA_PASSWORD);\n#endif //_RTT_WIFI_WPA\n\n#ifdef _RTT_WIFI_WPA2_ENTERPRISE\nchar wpa2username[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA2_USERNAME);\nchar wpa2password[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA2_PASSWORD);\n#endif //_RTT_WIFI_WPA2_ENTERPRISE\n#endif //(defined(_RTT_THINGSPEAK_WIFI_) || (_RTT_WIFI_TCP_ !=0) || defined(_RTT_WEBSOCKET_PORT_))\n\n#include \"MW_ArduinoHWInit.h\"\n#ifdef _MW_DASHBOARD_BLOCK_PRESENT_\n#include \"MW_graphicPrimitive.h\"\n#endif\n\n\n\nvoid MW_Modbus_Slave_Poll(void)\n{\n    #if defined(_RTT_MODBUS_SLAVE_)\n    ModbusRTUServer.poll();\n    #endif\n}\n\nvoid MW_ArduinoNano33BLESenseInit(void)\n{\n    #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    initVariant();\n    #if defined(SERIAL_CDC)\n    PluggableUSBD().begin();\n    _SerialUSB.begin(115200);\n    #endif\n    #if defined(_RTT_PWM_NANO33BLE_INUSE)\n    MW_NANO33BLE_PWM_Setup();\n    #endif\n    #endif\n}\n\nvoid MW_ArduinoNanoRP2040Init(void)\n{\n    #if defined(ARDUINO_NANO_RP2040_CONNECT)\n\tinit();\n\tinitVariant();\n    #if defined(SERIAL_CDC)\n    PluggableUSBD().begin();\n    _SerialUSB.begin(115200);\n    #endif\n    #endif\n}\n\nvoid UNOR4_Init(void) \n{\n    #if(defined(ARDUINO_ARCH_RENESAS_UNO))\n    // Disable stack pointer protection\n    // TODO: the best thing would be keeping SPMON active but changing\n    // R_MPU_SPMON->SP[0].EA = __stack_top; // on every call to malloc()\n    // When stack and heap would collide, we could signal the NMI with mbed style leds patterns\n    #if defined(__ARM_ARCH_8M_MAIN__) || defined(__ARM_ARCH_8M_BASE__)\n        __set_MSPLIM(0);\n        #if FSP_PRIV_TZ_USE_SECURE_REGS\n            unsecure_registers();\n        #endif\n    #else\n        R_MPU_SPMON->SP[0].CTL = 0;\n    #endif\n\n   __disable_irq();\n   irq_vector_table = (volatile uint32_t *)APPLICATION_VECTOR_TABLE_ADDRESS_RAM;\n   size_t _i;\n   for (_i=0; _i<BSP_CORTEX_VECTOR_TABLE_ENTRIES; _i++) {\n      *(irq_vector_table + _i) = (uint32_t)__VECTOR_TABLE[_i];\n   }\n   for (_i=0; _i<BSP_ICU_VECTOR_MAX_ENTRIES; _i++) {\n      *(irq_vector_table + _i +BSP_CORTEX_VECTOR_TABLE_ENTRIES) = (uint32_t)g_vector_table[_i];\n   }\n\n   SCB->VTOR = (uint32_t)irq_vector_table;\n\n   __DSB();\n   __enable_irq();\n\n    #ifdef BACKTRACE_SUPPORT\n       // \"install\" stacktrace print over Hardfault handler\n       *(irq_vector_table + 3) = (uint32_t)Stacktrace_Handler;\n       cm_backtrace_init(stringify(PROJECT_NAME), \"RA\", __DATE__ \"\\0\");\n    #endif\n\n    _init();\n     initVariant();\n    analogReference();\n\n   #ifndef NO_USB\n       __USBStart();\n       Serial.begin(115200);\n   #endif\n   startAgt();\n   #endif\n}\n\nvoid MW_ArduinoRaspberryPiPicoWInit(void)\n{\n    #if (defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO))\n\n    #if F_CPU != 125000000\n        set_sys_clock_khz(F_CPU / 1000, true);\n    #endif\n        \n    rp2040.begin();\n    initVariant();\n    rp2040.enableDoubleResetBootloader();\n\n    #ifndef NO_USB\n    #ifdef USE_TINYUSB\n    TinyUSB_Device_Init(0);\n\n    #else\n    __USBStart();\n\n    #ifndef DISABLE_USB_SERIAL\n    // Enable serial port for reset/upload always\n    Serial.begin(115200);\n    #endif\n    #endif\n    #endif\n\n    #endif\n}\n\nvoid MW_Arduino_Init(void)\n{\n    //Hardware specific init for Arduino nano 33 ble sense\n    #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    MW_ArduinoNano33BLESenseInit();\n    #endif\n    #if defined(ARDUINO_NANO_RP2040_CONNECT)\n    MW_ArduinoNanoRP2040Init();\n    #endif\n    #if (defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO))\n    MW_ArduinoRaspberryPiPicoWInit();\n    #endif\n    //Disable watchdog for Arduino Due. watchdog\n    #if (defined(_ROTH_DUE_))\n    watchdogDisable();\n    #endif\n    //Disable watchdog for ESP32\n    #if (defined(ESP_PLATFORM))\n    initArduino();\n    disableCore0WDT();\n    #endif\n\n    //Hardware specific init for Arduino UNO R4 WiFi\n    #if(defined(ARDUINO_ARCH_RENESAS_UNO))\n    UNOR4_Init();\n    #endif\n\n    /*\n    * Initialize Serial Peripheral\n    */\n    // Always Initialize Serial0\n    #if(defined(ESP_PLATFORM))\n    #else\n    Serial_begin(0, _RTT_BAUDRATE_SERIAL0_, _RTT_CONFIG_SERIAL0_);\n    #endif\n\n    /* Overrun Detection Initialization */\n    #ifdef _RTT_OVERRUN_DIGITAL_PIN_\n    pinMode(_RTT_OVERRUN_DIGITAL_PIN_, OUTPUT);\n\n    /* Init the overrun detection pin to zero or else the Pin is always in a\n    * high/tristate giving the user a wrong indication of overrun conditions */\n    digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, LOW);\n    #endif\n\n    /*\n    * Initialize Analog Reference Voltage\n    * Default - Due\n    * Default, Internal 1.1, Internal 2.56, External -  Mega 2560, Mega ADK\n    * Default, Internal 0.6, Internal 1.2, Internal 2.4 -  BLE Sense\n    * Default, Internal, External - Other Arduino targets\n    */\n    #if (defined(_ROTH_MEGA2560_))\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(INTERNAL1V1);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(INTERNAL2V56);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 3))\n    analogReference(EXTERNAL);\n    #endif\n    #elif defined(ARDUINO_ARM_CORTEX_M0_PLUS)\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(AR_INTERNAL1V0);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(AR_INTERNAL1V65);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 3))\n    analogReference(AR_INTERNAL2V23);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 4))\n    analogReference(AR_EXTERNAL);\n    #endif\n    #elif defined(ARDUINO_ARDUINO_NANO33BLE)\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(AR_VDD);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(AR_INTERNAL);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 3))\n    analogReference(AR_INTERNAL1V2);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 4))\n    analogReference(AR_INTERNAL2V4);\n    #endif\n    #elif defined(ARDUINO_UNOR4_WIFI)\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(AR_DEFAULT);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(AR_INTERNAL);\n    #endif\n    \n    #else\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(INTERNAL);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(EXTERNAL);\n    #endif\n    #endif\n\n    /*\n    * Initialize SPI bus\n    */\n    //_RTT_SPI_SSPIN_ definition is applicable for all boards excluding Due\n    #if (defined(_RTT_SPI_SSPIN_)) || (defined(MW_ARDUINO_OV2640CSPIN))\n    MW_SPIwriteReadSetup();\n    #endif\n\n    //Initialize Modbus\n    int modStatus;\n    #if defined(_RTT_MODBUS_MASTER_)\n    modStatus = ModbusRTUClient.begin(_RTT_RS485_BAUD_, _RTT_RS485_CONFIG_);\n    ModbusRTUClient.setTimeout(_RTT_MODBUS_MASTERTIMEOUT_/1000);\n    #endif\n\n    #if defined(_RTT_MODBUS_SLAVE_)\n    modStatus = ModbusRTUServer.begin(_RTT_MODBUS_SLAVEID_, _RTT_RS485_BAUD_, _RTT_RS485_CONFIG_);\n    #if defined(_RTT_MODBUS_CONFIGCOIL_)\n    ModbusRTUServer.configureCoils(_RTT_MODBUS_COILADDR_,_RTT_MODBUS_COILNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGINPUT_)\n    ModbusRTUServer.configureDiscreteInputs(_RTT_MODBUS_INPUPTADDR_,_RTT_MODBUS_INPUTNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGHOLDINGREG_)\n    ModbusRTUServer.configureHoldingRegisters(_RTT_MODBUS_HOLDINGREGADDR_,_RTT_MODBUS_HOLDINGREGNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGINPUTREG_)\n    ModbusRTUServer.configureInputRegisters(_RTT_MODBUS_INPUTREGADDR_,_RTT_MODBUS_INPUTREGNUM_);\n    #endif\n    #endif\n    /*\n    * Initialize wifi\n    */\n    #if (defined(_RTT_WIFI_UDP_) && (_RTT_WIFI_UDP_ != 0)) || (defined(_RTT_WIFI_TCP_) && (_RTT_WIFI_TCP_ != 0))|| defined(_RTT_THINGSPEAK_WIFI_) || defined(_RTT_WEBSOCKET_PORT_) || defined(_RTT_MQTT_WIFI_) || defined(_RTT_HTTP_CLIENT_)\n    /* Begin WiFi*/\n    while(configureSuccess!=WL_CONNECTED)\n    {\n        #if (defined(_RTT_DISABLE_Wifi_DHCP_) && (_RTT_DISABLE_Wifi_DHCP_ !=0))\n            #if defined(ESP_PLATFORM)\n                #if (_RTT_DISABLE_Wifi_DHCP_ == 1)\n                WiFi.config(wifiLocalIpAddress,wifigateway, subnet, dns1, dns2);\n                #else\n                WiFi.config(wifiLocalIpAddress, wifiGatewayAddress, wifiSubnetMask, wifiDNSAddress);\n                #endif\n            #elif (_RTT_DISABLE_Wifi_DHCP_ == 1)\n            WiFi.config(wifiLocalIpAddress);\n            #else\n            WiFi.config(wifiLocalIpAddress, wifiDNSAddress, wifiGatewayAddress, wifiSubnetMask);\n            #endif\n        #endif\n\n        #ifdef _RTT_WIFI_WEP\n        configureSuccess=WiFi.begin(ssid,keyIndex,key);\n        #endif //_RTT_WIFI_WEP\n\n        #ifdef _RTT_WIFI_WPA\n        configureSuccess=WiFi.begin(ssid,wpapass);\n        #endif //_RTT_WIFI_WPA\n\n        #ifdef _RTT_WIFI_WPA2_ENTERPRISE\n        #if defined(ESP_PLATFORM) \n        WiFi.disconnect(true);  //disconnect form wifi to set new wifi connection\n        WiFi.mode(WIFI_STA); //init wifi mode\n        configureSuccess = WiFi.begin(ssid, WPA2_AUTH_PEAP, wpa2username, wpa2username, wpa2password); //connect to wifi\n        \n        #elif defined(ARDUINO_UNOR4_WIFI)\n        WiFi.disconnect();  //disconnect form wifi to set new wifi connection\n        int extmodewifistatus = WiFi.begin(ssid,wpa2password); //connect to wifi\n        while (WiFi.status() != WL_CONNECTED) {\n            delay(500);\n        }\n        extmodewifistatus = WL_CONNECTED;\n\n        #elif defined(ARDUINO_WIFI_LIB_NINA)\n        configureSuccess=WiFi.beginEnterprise(ssid,wpa2username,wpa2password);\n        #endif\n        #endif //_RTT_WIFI_WPA2_ENTERPRISE\n\n        #ifdef _RTT_WIFI_NONE\n        configureSuccess=WiFi.begin(ssid);\n        #endif //_RTT_WIFI_NONE\n\n        #if (defined(ESP_PLATFORM)) || defined(ARDUINO_UNOR4_WIFI)\n        while (WiFi.status() != WL_CONNECTED) {\n            delay(500);\n        }\n        configureSuccess=WL_CONNECTED;\n        #else\n        //Wait for 10 seconds for Wifi connection to happen\n        unsigned long startMillis  = millis();\n        while(millis()- startMillis < 1000)\n        {\n        };\n        #endif // ESP_PLATFORM\n    }\n\n    /* Wait for Serial0 to be up*/\n    for(trialcount=0;trialcount<5;trialcount++)\n    {\n        if(Serial)\n        {\n            break;\n        }else\n        {\n            unsigned long startMillis  = millis();\n            while(millis()- startMillis < 1000)\n            {\n            };\n        }\n    }\n\n    #if (!(defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)))\n    if (configureSuccess==WL_CONNECTED)\n    {\n        // If the Configuration is successful, relay back the assigned IP address.\n        #if(defined(ESP_PLATFORM)) || defined(ARDUINO_UNOR4_WIFI)\n        Serial_begin(0, _RTT_BAUDRATE_SERIAL0_, _RTT_CONFIG_SERIAL0_);\n        #endif\n        IPAddress ip = WiFi.localIP();\n        //Adding a precautionary check using a Serial command so as to print the IP address so that it is available at least 6 times\n        //and the chances of it not being assigned to Target are minimised.\n        int ipSendcounter = 0; // Initialize counter\n        while ((Serial.read()!= 0xaa)  && ipSendcounter < ( _RTT_WIFI_TIMEOUT * 2)){\n         ipSendcounter++; // Increment counter at the end of each loop iteration\n            delay(500);\n        }\n\n        Serial.print(\"<<< IP address :\");\n        Serial.print(ip);\n        Serial.println(\" >>>\");\n        \n    }\n    else\n    {\n        // If the Configuration failed,relay back the error message.\n        Serial.println(\"<<< IP address :Failed to configure. >>>\");\n        Serial.print(_RTT_WIFI_TIMEOUT);\n    }\n    #endif //(!(defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)))\n\n    #endif /*Initialize wifi*/\n    #ifdef NANO_MOTOR_CARRIER\n    MW_EnableNanoCarrierBatteryCharging();\n    #endif\n    #ifdef _MW_DASHBOARD_BLOCK_PRESENT_\n    MW_initScreen();\n    #endif\n\n    #if defined(ARDUINO_ARCH_SAMD) && defined(MW_SAMD_EVSYS_ENABLE)\n    PM->APBCMASK.reg |= PM_APBCMASK_EVSYS;                                              // Switch on the event system peripheral\n    #if defined(MW_SAMD_EVSYS_CH0)\n    EVSYS->USER.reg = EVSYS_USER_CHANNEL(1) |                                           // Attach the event user (receiver) to channel 0 (n + 1)\n        EVSYS_USER_USER(EVSYS_CH0_USER_EVENT);                            // Set the event user (receiver) as EVSYS_CH1_USER_EVENT\n    EVSYS->CHANNEL.reg = EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT |                           // No event edge detection\n        EVSYS_CHANNEL_PATH_ASYNCHRONOUS |                              // Set event path as asynchronous\n        EVSYS_CHANNEL_EVGEN(EVSYS_CH0_GEN_EVENT) |                     // Set event generator (sender) as EVSYS_CH1_GEN_EVENT\n        EVSYS_CHANNEL_CHANNEL(0);                                      // Attach the generator (sender) to channel 0\n    EVSYS_CH0_USER->EVCTRL.reg |= EVSYS_CH0_USER_START_CMD;\n    EVSYS_CH0_GEN->EVCTRL.reg |= EVSYS_CH0_GEN_START_CMD;\n    #endif\n    #if defined(MW_SAMD_EVSYS_CH1)\n    EVSYS->USER.reg = EVSYS_USER_CHANNEL(2) |                                           // Attach the event user (receiver) to channel 1 (n + 1)\n        EVSYS_USER_USER(EVSYS_CH1_USER_EVENT);                            // Set the event user (receiver) as EVSYS_CH2_USER_EVENT\n    EVSYS->CHANNEL.reg = EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT |                           // No event edge detection\n        EVSYS_CHANNEL_PATH_ASYNCHRONOUS |                              // Set event path as asynchronous\n        EVSYS_CHANNEL_EVGEN(EVSYS_CH1_GEN_EVENT) |                     // Set event generator (sender) as EVSYS_CH2_GEN_EVENT\n        EVSYS_CHANNEL_CHANNEL(1);                                      // Attach the generator (sender) to channel 1\n    EVSYS_CH1_USER->EVCTRL.reg |= EVSYS_CH1_USER_START_CMD;\n    EVSYS_CH1_GEN->EVCTRL.reg |= EVSYS_CH1_GEN_START_CMD;\n    #endif\n    #if defined(MW_SAMD_EVSYS_CH2)\n    EVSYS->USER.reg = EVSYS_USER_CHANNEL(3) |                                           // Attach the event user (receiver) to channel 2 (n + 1)\n        EVSYS_USER_USER(EVSYS_CH2_USER_EVENT);                            // Set the event user (receiver) as EVSYS_CH3_USER_EVENT\n    EVSYS->CHANNEL.reg = EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT |                           // No event edge detection\n        EVSYS_CHANNEL_PATH_ASYNCHRONOUS |                              // Set event path as asynchronous\n        EVSYS_CHANNEL_EVGEN(EVSYS_CH2_GEN_EVENT) |                     // Set event generator (sender) as EVSYS_CH3_GEN_EVENT\n        EVSYS_CHANNEL_CHANNEL(2);                                      // Attach the generator (sender) to channel 2\n    EVSYS_CH2_USER->EVCTRL.reg |= EVSYS_CH2_USER_START_CMD;\n    EVSYS_CH2_GEN->EVCTRL.reg |= EVSYS_CH2_GEN_START_CMD;\n    #endif\n    #if defined(MW_SAMD_EVSYS_CH3)\n    EVSYS->USER.reg = EVSYS_USER_CHANNEL(4) |                                           // Attach the event user (receiver) to channel 3 (n + 1)\n        EVSYS_USER_USER(EVSYS_CH3_USER_EVENT);                            // Set the event user (receiver) as EVSYS_CH4_USER_EVENT\n    EVSYS->CHANNEL.reg = EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT |                           // No event edge detection\n        EVSYS_CHANNEL_PATH_ASYNCHRONOUS |                              // Set event path as asynchronous\n        EVSYS_CHANNEL_EVGEN(EVSYS_CH3_GEN_EVENT) |                     // Set event generator (sender) as EVSYS_CH4_GEN_EVENT\n        EVSYS_CHANNEL_CHANNEL(3);                                      // Attach the generator (sender) to channel 3\n    EVSYS_CH3_USER->EVCTRL.reg |= EVSYS_CH3_USER_START_CMD;\n    EVSYS_CH3_GEN->EVCTRL.reg |= EVSYS_CH3_GEN_START_CMD;\n    #endif\n    #endif\n}\n/* Function: MW_Arduino_Terminate ================================================\n* For Arduino MKR/Leonardo and its variants, the Virtual COM port is handled\n* by the controller. In case the code running on the target exits main,\n* the COM port cannot be accessed until a hard reset is performed.\n* To over come this issue, a while loop is added to make sure that\n* upon getting a stop command from external mode, the code running on\n* the target stops but the code will not exit the main.\n* This will ensure that the COM port is accessible even after the\n* external mode has been stopped. */\nvoid MW_Arduino_Terminate(void){\n    #if defined(ARDUINO_VIRTUAL_COM_PORT) || (defined(ARDUINO_ARDUINO_NANO33BLE) && (!defined(USE_MBEDRTOS))) || defined(__IMXRT1062__) || (defined(ARDUINO_NANO_RP2040_CONNECT) && (!defined(USE_MBEDRTOS))) || defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO)\n    disable_rt_OneStep();\n    while(1){};     /* To continue virtual COM port functionality */\n    #endif    \n}\n\n#ifdef NANO_MOTOR_CARRIER\nvoid MW_EnableNanoCarrierBatteryCharging(void) {\n    Wire.begin();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG00);\n    Wire.write(0x06); // min sys voltage 3.88V + max input current 2.0 A\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG01);\n    Wire.write(0x1B); // Charge Battery + Minimum System Voltage 3.5V\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG02);\n    Wire.write(0x00); // Charge current  512 mA\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG04);\n    Wire.write(0x9E); // Charge Voltage Limit 4.128V\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG05);\n    Wire.write(0x8A); // Enable Battery Charge termination + disable watchdog\n    Wire.endTransmission();\n}\n#endif\n\n\n// Overrun detection function for ESP32\n#if defined(ESP_PLATFORM) && defined(_RTT_OVERRUN_DIGITAL_PIN_)\nvoid onOverrunDetect(int id)\n{\n    digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n}\n#endif\n// LocalWords:  AVR Bareboard ADK SPI RTT SSPIN Modbus MKR"},{"name":"MW_PWM.cpp","type":"source","group":"legacy","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2015-2024 The MathWorks, Inc. */\n\n#include \"MW_PWM.h\"\n#include \"MW_PWMDriver.h\"\n\n#if (defined(ESP_PLATFORM))\n//#include \"soc/soc_caps.h\" This file is present in new core of esp32. Uncomment and remove SOC_GPIO_PIN_COUNT defination once esp32 core is updated\n#define SOC_GPIO_PIN_COUNT              40\n#endif\n\n#if !(( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) ))\n#include \"Arduino.h\"\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define PWM_MODULES_MAX 70  /* For Mega and Due. Other boards have less number of Modules */\nstatic uint8_T PinMapTable[MW_NUM_PINS]={0};\n#if (defined(ARDUINO_ARDUINO_NANO33BLE))\nuint32_t nano33BLE_dutycycle[21];\nuint16_t nano33BLE_period[21];\n#endif\n\ntypedef uint8_T PeripheralHandleMapType;\nextern PeripheralHandleMapType PWMPinHandleMap[];     /* The array is defined in ArduinoPinHandleMap.cpp */\n\n/* For PWM SVd provides no function to get the handle */\nMW_Handle_Type MW_PWM_GetHandle(uint32_T Pin);\nvoid setPWMHandle(uint32_T Pin, MW_Handle_Type handle);\n\n#if (defined(ESP_PLATFORM))\n#define ESP32_PWM_RESOLUTION            8\n#if (defined(_RTT_NUMSERVOS_) && (_RTT_NUMSERVOS_ != 0))\n#define LAST_CHAN (8)\n#else\n#define LAST_CHAN (16)\n#endif\nstatic int8_t pin_to_channel[SOC_GPIO_PIN_COUNT] = { 0 };\nstatic int channelCounter = LAST_CHAN;\n#endif\n\n/* PWM Initialisation selected by the pinNumber (PWM Channel) */\nMW_Handle_Type MW_PWM_Open(uint32_T pin, real_T prescaler, real_T period)\n{\n    #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n    /* This will be run in Rapid Accelerator Mode */\n    return NULL;\n    #else\n    #if (defined(ESP_PLATFORM))\n    if (pin < SOC_GPIO_PIN_COUNT) {\n        if (pin_to_channel[pin] == 0) {\n            if (!channelCounter) {\n                log_e(\"No more analogWrite channels available! You can have maximum %u\", LAST_CHAN);\n                return 0;\n            }\n            pinMode(pin,OUTPUT);\n            pin_to_channel[pin] = channelCounter ;\n            ledcAttachPin(pin, channelCounter-1);\n            if(prescaler == 0)                    // Default frequency\n            {\n                ledcSetup(channelCounter-1, ARDUINO_DEFAULT_PWM_FREQUENCY, ESP32_PWM_RESOLUTION);\n            }\n            else\n            {\n                ledcSetup(channelCounter-1, prescaler, ESP32_PWM_RESOLUTION);\n            }\n            if(period>0)\n            {\n                channelCounter = channelCounter-2;    // Use only one channel from channel pair\n            }\n            else\n            {\n                channelCounter = channelCounter-1;\n            }\n            \n        }\n        ledcWrite(pin_to_channel[pin] - 1, 0);\n    }else{\n        return 0;\n    }\n    setPWMHandle(pin, (MW_Handle_Type)(pin+1));\n    return (MW_Handle_Type)(pin+1);\n\n    #elif defined(__IMXRT1062__)\n    #include \"core_pins.h\"\n    if(prescaler > 0)                    // Specify Frequency\n    {\n        PinMapTable[pin]=1;\n        analogWriteFrequency(pin,prescaler);\n    }\n    setPWMHandle(pin, (MW_Handle_Type)(pin+1));\n    return (MW_Handle_Type)(pin+1);\n\n    #else\n    pinMode(pin,OUTPUT);\n\n    #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    nano33BLE_dutycycle[pin] = 0;\n    nano33BLE_period[pin] = 1000000/500;\n    #elif (defined(ARDUINO_NANO_RP2040_CONNECT) || defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO))\n    // RP2040 uses a hardware PWM, hence we need to use the prescaler,period values based on the default frequency configset parameter\n    if(prescaler == 0)                    // Default frequency\n    {\n      MW_setAnalogFrequency(pin, ARDUINO_RP2040_DEFAULT_PWM_PRESCALER, ARDUINO_RP2040_DEFAULT_PWM_PERIOD);\n    }\n    #endif\n    /* handle is stored as Pin+1 because, to reset the handle of a pin, 0 is passed as handle. Otherwise it will create confusion for Pin number 0. */\n    setPWMHandle(pin, (MW_Handle_Type)(pin+1));\n\n    if(period>0) /*Initialization needed for specify frequnecy*/\n    {\n        PinMapTable[pin]=1;\n        MW_setAnalogFrequency(pin, prescaler,period);\n    }\n    return (MW_Handle_Type)(pin+1);\n    #endif\n    #endif\n}\n\n/* Start PWM */\nvoid MW_PWM_Start(MW_Handle_Type PWMPinHandle)\n{\n    (void)PWMPinHandle;\n}\n\n/* Set the duty cycle or pulse width for the PWM signal */\nvoid MW_PWM_SetDutyCycle(MW_Handle_Type PWMPinHandle, real_T dutyCycle)\n{\n    #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n    /* This will be run in Rapid Accelerator Mode */\n    (void)PWMPinHandle;\n    (void)dutyCycle;\n    return;\n    #else\n    #if (defined(ESP_PLATFORM))\n    uint8_T pin;\n    if(*((uint8_T*)(&PWMPinHandle)))\n    {\n        /* The handle of a Pin is stored as (Pin+1) */\n        pin =  *((uint8_T*)(&PWMPinHandle)) - 1;\n        if(dutyCycle < 0)       /* Changed frequency */\n        {\n            dutyCycle = dutyCycle * -1;\n        }\n        ledcWrite(pin_to_channel[pin] - 1, dutyCycle);\n    }\n    #elif defined(__IMXRT1062__)\n    uint8_T pin;\n    if(*((uint8_T*)(&PWMPinHandle)))\n    {\n        /* The handle of a Pin is stored as (Pin+1) */\n        pin =  *((uint8_T*)(&PWMPinHandle)) - 1;\n        if(PinMapTable[pin]==1)       /* Changed frequency */\n        {\n            dutyCycle = dutyCycle * -1; \n        }\n\n        analogWrite(pin, dutyCycle);\n    }\n    #else\n    uint8_T pin;\n    /* If the PWM handle is 0 then do nothing. */\n    if(*((uint8_T*)(&PWMPinHandle)))\n    {\n        /* The handle of a Pin is stored as (Pin+1) */\n        pin =  *((uint8_T*)(&PWMPinHandle)) - 1;\n        if( PinMapTable[pin]==1)       /* make sure MW_analogWrite gets executed at Specify Frequency*/\n        {\n            dutyCycle = dutyCycle * -1;\n            MW_analogWrite(pin, dutyCycle);\n        }\n        else                    /* Default frequency*/\n        {\n            #if defined(ARDUINO_ARDUINO_NANO33BLE)\n            nano33BLE_period[pin] = 1000000/500; //Default frequency of 500Hz\n            nano33BLE_dutycycle[pin] = (dutyCycle* nano33BLE_period[pin]/255);\n            #elif (defined(ARDUINO_NANO_RP2040_CONNECT) || defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO))\n            MW_analogWrite(pin, ((dutyCycle/255) * ARDUINO_RP2040_DEFAULT_PWM_PERIOD));\n            #else\n            analogWrite(pin, dutyCycle);\n            #endif\n        }\n    }\n    #endif\n    #endif\n}\n\n/* Set the PWM signal frequency */\nvoid MW_PWM_SetFrequency(MW_Handle_Type PWMPinHandle, real_T frequency)\n{\n    (void)PWMPinHandle;\n    (void)frequency;\n}\n\n/* Disable notifications on the channel */\nvoid MW_PWM_DisableNotification(MW_Handle_Type PWMPinHandle)\n{\n    (void)PWMPinHandle;\n}\n\n/* Enable notifications on the channel */\nvoid MW_PWM_EnableNotification(MW_Handle_Type PWMPinHandle, MW_PWM_EdgeNotification_Type Notification)\n{\n    (void)PWMPinHandle;\n    (void)Notification;\n}\n\n/* Set PWM output to idle state */\nvoid MW_PWM_SetOutputToIdle(MW_Handle_Type PWMPinHandle)\n{\n    (void)PWMPinHandle;\n}\n\n/* Get the PWM output status */\nboolean_T MW_PWM_GetOutputState(MW_Handle_Type PWMPinHandle)\n{\n    (void)PWMPinHandle;\n    return 0;\n}\n\n/* Stop PWM */\nvoid MW_PWM_Stop(MW_Handle_Type PWMPinHandle)\n{\n    (void)PWMPinHandle;\n}\n\n/* Close PWM */\nvoid MW_PWM_Close(MW_Handle_Type PWMPinHandle)\n{\n    #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n    return;\n    #else\n    /* If the PWM handle is 0 then do nothing. */\n    if(*((uint8_T*)(&PWMPinHandle)))\n    {\n        uint8_T pin = 0;\n        /* The handle of a Pin is stored as (Pin+1) */\n        pin =  *((uint8_T*)(&PWMPinHandle)) - 1;\n        setPWMHandle(pin, (MW_Handle_Type)0);\n    }\n    (void)PWMPinHandle;\n    #endif\n}\n\nMW_Handle_Type MW_PWM_GetHandle(uint32_T Pin)\n{\n    #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n    return NULL;\n    #else\n    uint16_T ByteNo=0, handleValue=0;\n\n    uint8_T BitPositionNo=0;\n\n    ByteNo = Pin/8;\n    BitPositionNo = Pin%8;\n\n    handleValue = PWMPinHandleMap[ByteNo] & (PeripheralHandleMapType)(1<<BitPositionNo);\n\n    if(handleValue)\n    {\n        /*\n        Returns the value of the module if the pin is opened earlier\n        */\n        handleValue = Pin+1;\n        /*\n        This allows to differentiate between pin zero and a Null condition\n\n        Another option - return true, and then remove the decrement in the SVD of all functions in Arduino\n        */\n    }\n    else\n    {\n        handleValue = 0;\n    }\n    return (MW_Handle_Type)handleValue;\n    #endif\n}\n\nvoid setPWMHandle(uint32_T module, MW_Handle_Type handle)\n{\n    #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n    return;\n    #else\n    /*\n    Assumes pin number from count zero\n    */\n    uint16_T ByteNo=0;\n    uint8_T BitPositionNo=0;\n    PeripheralHandleMapType tempVar=0;\n    /*\n    Integer division rounds off to value providing the abs byte no\n    */\n    ByteNo = module/8;\n    BitPositionNo = module%8;\n\n    tempVar = (1<<BitPositionNo);\n    /*\n    The assumption is module number is the handle,\n    but when handle is Null, reset the handle\n    */\n    if(!handle)\n    {\n        /*reset the handle*/\n        tempVar = ~tempVar;\n        PWMPinHandleMap[ByteNo] = PWMPinHandleMap[ByteNo] & tempVar;\n    }\n    else\n    {\n        /*set the handle*/\n        PWMPinHandleMap[ByteNo] = PWMPinHandleMap[ByteNo] | tempVar;\n    }\n    #endif\n}\n\n#ifdef __cplusplus\n}\n#endif\n#else\nMW_Handle_Type MW_PWM_Open(uint32_T pin, real_T frequency, real_T dutyCycle){return 0;}\nvoid MW_PWM_Start(MW_Handle_Type PWMPinHandle){}\nvoid MW_PWM_SetDutyCycle(MW_Handle_Type PWMPinHandle, real_T dutyCycle){}\nvoid MW_PWM_SetFrequency(MW_Handle_Type PWMPinHandle, real_T frequency){}\nvoid MW_PWM_DisableNotification(MW_Handle_Type PWMPinHandle){}\nvoid MW_PWM_EnableNotification(MW_Handle_Type PWMPinHandle, MW_PWM_EdgeNotification_Type Notification){}\nvoid MW_PWM_SetOutputToIdle(MW_Handle_Type PWMPinHandle){}\nboolean_T MW_PWM_GetOutputState(MW_Handle_Type PWMPinHandle){return 0;}\nvoid MW_PWM_Stop(MW_Handle_Type PWMPinHandle){}\nvoid MW_PWM_Close(MW_Handle_Type PWMPinHandle){}\nMW_Handle_Type MW_PWM_GetHandle(uint32_T Pin){return 0;}\n#endif\n"},{"name":"MW_PWMDriver.c","type":"source","group":"legacy","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Code to configure Timer and set duty cycle\n * This file is modified version of wiring_analog.c file\n * It separates analogWrite function into two parts:\n * 1. MW_setAnalogFrequency: This function initializes PWM peripheral\n * 2. MW_analogWrite: This function sets the duty cycle\n * /* Copyright 2019-2024 The MathWorks, Inc. */\n\n#include \"MW_PWMDriver.h\"\n\n#if !( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n\n#if defined(ARDUINO_ARCH_SAMD)                                                          /* SAMD Targets */\n#include \"Arduino.h\"\n#include \"wiring_private.h\"\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic int _writeResolution = 8;\n\n// Wait for synchronization of registers between the clock domains\nstatic __inline__ void syncDAC() __attribute__((always_inline, unused));\nstatic void syncDAC() {\n  while (DAC->STATUS.bit.SYNCBUSY == 1)\n    ;\n}\n\n// Wait for synchronization of registers between the clock domains\nstatic __inline__ void syncTC_8(Tc* TCx) __attribute__((always_inline, unused));\nstatic void syncTC_8(Tc* TCx) {\n  while (TCx->COUNT8.STATUS.bit.SYNCBUSY);\n}\n\n// Wait for synchronization of registers between the clock domains\nstatic __inline__ void syncTCC(Tcc* TCCx) __attribute__((always_inline, unused));\nstatic void syncTCC(Tcc* TCCx) {\n  while (TCCx->SYNCBUSY.reg & TCC_SYNCBUSY_MASK);\n}\n\nstatic inline uint32_t mapResolution(uint32_t value, uint32_t from, uint32_t to)\n{\n  if (from == to) {\n    return value;\n  }\n  if (from > to) {\n    return value >> (from-to);\n  }\n  return value << (to-from);\n}\n\nvoid MW_analogWrite(uint32_t pin, uint32_t value)\n{\n  PinDescription pinDesc = g_APinDescription[pin];\n  uint32_t attr = pinDesc.ulPinAttribute;\n\n  if ((attr & PIN_ATTR_ANALOG) == PIN_ATTR_ANALOG)\n  {\n    // DAC handling code\n\n    if ((pinDesc.ulADCChannelNumber != ADC_Channel0) && (pinDesc.ulADCChannelNumber != DAC_Channel0)) { // Only 1 DAC on AIN0 / PA02\n      return;\n    }\n\n    value = mapResolution(value, _writeResolution, 10);\n\n    syncDAC();\n    DAC->DATA.reg = value & 0x3FF;  // DAC on 10 bits.\n    syncDAC();\n    DAC->CTRLA.bit.ENABLE = 0x01;     // Enable DAC\n    syncDAC();\n    return;\n  }\n\n  if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)\n  {\n    //value = mapResolution(value, _writeResolution, 16);\n\n    uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);\n    uint8_t tcChannel = GetTCChannelNumber(pinDesc.ulPWMChannel);\n\n    if (attr & PIN_ATTR_TIMER) {\n      #if !(ARDUINO_SAMD_VARIANT_COMPLIANCE >= 10603)\n      // Compatibility for cores based on SAMD core <=1.6.2\n      if (pinDesc.ulPinType == PIO_TIMER_ALT) {\n        pinPeripheral(pin, PIO_TIMER_ALT);\n      } else\n      #endif\n      {\n        pinPeripheral(pin, PIO_TIMER);\n      }\n    } else {\n      // We suppose that attr has PIN_ATTR_TIMER_ALT bit set...\n      pinPeripheral(pin, PIO_TIMER_ALT);\n    }\n\n    \n    if (tcNum >= TCC_INST_NUM) {\n        Tc* TCx = (Tc*) GetTC(pinDesc.ulPWMChannel);\n        TCx->COUNT8.CC[tcChannel].reg = (uint32_t) value;\n        syncTC_8(TCx);\n    } else {\n        Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);\n        //Disabling the double buffer lock for now.\n        //If this is enabled, in double slope mode,\n        //Counter wraparound occurs which results in \n        //unexpected duty cycles. This needs to be fixed/\n        //Not behaving as per datasheet\n        //TCCx->CTRLBSET.bit.LUPD = 1;\n        //syncTCC(TCCx);\n        TCCx->CCB[tcChannel].reg = (uint32_t) value;\n        syncTCC(TCCx);\n        //TCCx->CTRLBCLR.bit.LUPD = 1;\n        //syncTCC(TCCx);\n    }\n    return;\n  }\n\n  // -- Defaults to digital write\n  pinMode(pin, OUTPUT);\n  value = mapResolution(value, _writeResolution, 8);\n  if (value < 128) {\n    digitalWrite(pin, LOW);\n  } else {\n    digitalWrite(pin, HIGH);\n  }\n}\n\nvoid MW_setAnalogFrequency(uint16_t pin,uint16_t prescaler,uint16_t period)\n{\n  uint32_t value = 0;                 \n  PinDescription pinDesc = g_APinDescription[pin];\n  uint32_t attr = pinDesc.ulPinAttribute;\n\n  if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)\n  {\n    //value = mapResolution(value, _writeResolution, 16);\n    uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);\n    uint8_t tcChannel = GetTCChannelNumber(pinDesc.ulPWMChannel);\n    static bool tcEnabled[TCC_INST_NUM+TC_INST_NUM];\n\n    if (attr & PIN_ATTR_TIMER) {\n      #if !(ARDUINO_SAMD_VARIANT_COMPLIANCE >= 10603)\n      // Compatibility for cores based on SAMD core <=1.6.2\n      if (pinDesc.ulPinType == PIO_TIMER_ALT) {\n        pinPeripheral(pin, PIO_TIMER_ALT);\n      } else\n      #endif\n      {\n        pinPeripheral(pin, PIO_TIMER);\n      }\n    } else {\n      // We suppose that attr has PIN_ATTR_TIMER_ALT bit set...\n      pinPeripheral(pin, PIO_TIMER_ALT);\n    }\n\n    if (!tcEnabled[tcNum]) {\n      tcEnabled[tcNum] = true;\n\n      uint16_t GCLK_CLKCTRL_IDs[] = {\n        GCLK_CLKCTRL_ID(GCM_TCC0_TCC1), // TCC0\n        GCLK_CLKCTRL_ID(GCM_TCC0_TCC1), // TCC1\n        GCLK_CLKCTRL_ID(GCM_TCC2_TC3),  // TCC2\n        GCLK_CLKCTRL_ID(GCM_TCC2_TC3),  // TC3\n        GCLK_CLKCTRL_ID(GCM_TC4_TC5),   // TC4\n        GCLK_CLKCTRL_ID(GCM_TC4_TC5),   // TC5\n        GCLK_CLKCTRL_ID(GCM_TC6_TC7),   // TC6\n        GCLK_CLKCTRL_ID(GCM_TC6_TC7),   // TC7\n      };\n      GCLK->CLKCTRL.reg = (uint16_t) (GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_IDs[tcNum]);\n      while (GCLK->STATUS.bit.SYNCBUSY == 1);\n\n      // Set PORT\n      if (tcNum >= TCC_INST_NUM) {\n        // -- Configure TC\n        Tc* TCx = (Tc*) GetTC(pinDesc.ulPWMChannel);\n        // Disable TCx\n        TCx->COUNT8.CTRLA.bit.ENABLE = 0;\n        syncTC_8(TCx);\n        // Set Timer counter Mode to 16 bits, normal PWM\n        TCx->COUNT8.CTRLA.reg |= TC_CTRLA_MODE_COUNT8 | TC_CTRLA_WAVEGEN_NPWM | (prescaler<<8);\n        syncTC_8(TCx);\n        // Set the initial value\n        TCx->COUNT8.CC[tcChannel].reg = (uint32_t) value;\n        syncTC_8(TCx);\n        //freq is fTC/(N*(TOP+1))\n        TCx->COUNT8.PER.reg = period - 1;\n        syncTC_8(TCx);\n        // Enable TCx\n        TCx->COUNT8.CTRLA.bit.ENABLE = 1;\n        syncTC_8(TCx);\n      } else {\n        // -- Configure TCC\n        Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);\n        // Disable TCCx\n        TCCx->CTRLA.bit.ENABLE = 0;\n        syncTCC(TCCx);\n        // Prescaler\n        TCCx->CTRLA.reg |= (prescaler<<8);\n        syncTCC(TCCx);\n        // Set TCCx as dual slope PWM\n        TCCx->WAVE.reg |= TCC_WAVE_WAVEGEN_DSTOP;\n        //Invert the polarity because by default, ouput is high when counter > period\n        TCCx->WAVE.reg |= TCC_WAVE_POL_Msk; \n        syncTCC(TCCx);\n        // Set the initial value\n        TCCx->CC[tcChannel].reg = (uint32_t) value;\n        syncTCC(TCCx);\n        //No 'period-1' required in dual slope because freq = fTCC/(2N*PER) . Refer RM page 716 section 31.6.2.5.6\n        TCCx->PER.reg = period;\n        syncTCC(TCCx);\n        // Enable TCCx\n        TCCx->CTRLA.bit.ENABLE = 1;\n        syncTCC(TCCx);\n      }\n    }\n    return;\n  }\n    // -- Defaults to digital write\n  pinMode(pin, OUTPUT);\n  value = mapResolution(value, _writeResolution, 8);\n  if (value < 128) {\n    digitalWrite(pin, LOW);\n  } else {\n    digitalWrite(pin, HIGH);\n  }\n}\n\n/*Configure Output Polarity*/\nvoid MW_ConfigureOutputPolarity(uint8_T pin,boolean_T invertedPolarity){\n    PinDescription pinDesc = g_APinDescription[pin];\n    uint32_t attr = pinDesc.ulPinAttribute;\n    if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)\n    {\n        uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);\n        uint8_t tcChannel = GetTCChannelNumber(pinDesc.ulPWMChannel);\n        if (tcNum < TCC_INST_NUM) {\n            // -- Configure TCC\n            Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);\n            // Disable TCCx\n            TCCx->CTRLA.bit.ENABLE = 0;\n            syncTCC(TCCx);\n            // Invert the corresponding POL bit of WAVE register\n            TCCx->WAVE.reg ^= ((1<<(TCC_WAVE_POL0_Pos + tcChannel)) & TCC_WAVE_POL_Msk); \n            syncTCC(TCCx);\n            // Enable TCCx\n            TCCx->CTRLA.bit.ENABLE = 1;\n            syncTCC(TCCx);\n        }\n    }\n}\n\n/*Enable PWM Match Interrupt*/\nvoid MW_EnablePWMMatchInterrupt(uint8_T pin){\n    PinDescription pinDesc = g_APinDescription[pin];\n    uint32_t attr = pinDesc.ulPinAttribute;\n    if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)\n    {\n        uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);\n        uint8_t tcChannel = GetTCChannelNumber(pinDesc.ulPWMChannel);\n        if (tcNum < TCC_INST_NUM) {\n            // -- Configure TCC\n            Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);\n            // Disable TCCx\n            TCCx->CTRLA.bit.ENABLE = 0;\n            syncTCC(TCCx);\n            //Set the corresponsding MC bit in interrupt set register\n            TCCx->INTENSET.reg |= ((1<<(TCC_INTENSET_MC0_Pos + tcChannel)) & TCC_INTENSET_MC_Msk);\n            syncTCC(TCCx);\n            // Enable TCCx\n            TCCx->CTRLA.bit.ENABLE = 1;\n            syncTCC(TCCx);\n        }\n    }\n}\n\n/*Enable PWM Overflow Interrupt*/\nvoid MW_EnablePWMOverflowInterrupt(uint8_T pin){\n    PinDescription pinDesc = g_APinDescription[pin];\n    uint32_t attr = pinDesc.ulPinAttribute;\n    if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)\n    {\n        uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);\n        if (tcNum < TCC_INST_NUM) {\n            // -- Configure TCC\n            Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);\n            // Disable TCCx\n            TCCx->CTRLA.bit.ENABLE = 0;\n            syncTCC(TCCx);\n            //Enable Overflow Interrupt\n            TCC0->INTENSET.bit.OVF = 1;\n            syncTCC(TCCx);\n            // Enable TCCx\n            TCCx->CTRLA.bit.ENABLE = 1;\n            syncTCC(TCCx);\n        }\n    }\n}\n\n/*Set wave generation mode*/\nvoid MW_SetWavegenMode(uint8_T pin,uint8_T wavegenMode){\n    PinDescription pinDesc = g_APinDescription[pin];\n    uint32_t attr = pinDesc.ulPinAttribute;\n    if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)\n    {\n        uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);\n        if (tcNum < TCC_INST_NUM) {\n            // -- Configure TCC\n            Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);\n            // Disable TCCx\n            TCCx->CTRLA.bit.ENABLE = 0;\n            syncTCC(TCCx);\n            // Set TCCx wave mode\n            TCCx->WAVE.bit.WAVEGEN = wavegenMode;\n            syncTCC(TCCx);\n            // Enable TCCx\n            TCCx->CTRLA.bit.ENABLE = 1;\n            syncTCC(TCCx);\n        }\n    }\n}\n   \n#ifdef __cplusplus\n}\n#endif\n#elif defined(ARDUINO_ARDUINO_NANO33BLE)\n#include \"Arduino.h\"\n#include \"pins_arduino.h\"\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic int _writeResolution = 8;\n\nextern uint32_t nano33BLE_dutycycle[21];\nextern uint16_t nano33BLE_period[21];\n\nstatic inline uint32_t mapResolution(uint32_t value, uint32_t from, uint32_t to)\n{\n  if (from == to) {\n    return value;\n  }\n  if (from > to) {\n    return value >> (from-to);\n  }\n  return value << (to-from);\n}\n\nvoid MW_analogWrite(uint32_t pin, uint32_t value)\n{\n  nano33BLE_dutycycle[pin] = value;\n}\n\nvoid MW_setAnalogFrequency(uint16_t pin,uint16_t prescaler,uint16_t period)\n{\n    nano33BLE_period[pin] = period;\n}\n   \n#ifdef __cplusplus\n}\n#endif\n\n#elif (defined(ARDUINO_NANO_RP2040_CONNECT) || defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO)) // RP2040 targets\n#include \"hardware/pwm.h\"\n#include \"hardware/gpio.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(ARDUINO_NANO_RP2040_CONNECT)\n// Inclusion of required files to get digitalPinToPinName is causing compilation errors saying cstddef is not defined. \n// It is most likely to do with our main being a c file.\n// Force defining it here as a workaround\nuint8_t digitalPinToPinName[] = {1,0,25,15,16,17,18,19,20,21,5,7,4,6,26,27,28,29,12,13};// D0 to D19\n#elif (defined(ARDUINO_RASPBERRY_PI_PICO) || defined(ARDUINO_RASPBERRY_PI_PICO_W))\nuint8_t digitalPinToPinName[]  = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,26,27,28};  // D0 to D28   \n#endif\n\nvoid MW_analogWrite(uint32_t pin, uint32_t value)\n{\n  pwm_set_gpio_level(digitalPinToPinName[pin], value);\n}\n\nvoid MW_setAnalogFrequency(uint16_t pin, uint16_t clkDiv, uint16_t countWrap)\n{\n    uint8_t slice_num = pwm_gpio_to_slice_num(digitalPinToPinName[pin]);\n\n    // Get some sensible defaults for the slice configuration. By default, the\n    // counter is allowed to wrap over its maximum range (0 to 2**16-1)\n    pwm_config cfg = pwm_get_default_config();\n    \n    // Set divider, reduces counter clock to sysclock/this value\n    pwm_config_set_clkdiv(&cfg, clkDiv);\n    pwm_config_set_wrap(&cfg, countWrap);\n    \n    // Load the configuration into our PWM slice, and set it running.\n    #if defined(ARDUINO_NANO_RP2040_CONNECT)\n    pwm_init(slice_num, pwm_gpio_to_channel(digitalPinToPinName[pin]), &cfg, true);\n    #elif (defined(ARDUINO_RASPBERRY_PI_PICO) || defined(ARDUINO_RASPBERRY_PI_PICO_W))\n    pwm_init(slice_num, &cfg, true);\n    #endif\n    gpio_set_function(digitalPinToPinName[pin], GPIO_FUNC_PWM);\n    // Set zero dutycycle at setup call\n    pwm_set_gpio_level(digitalPinToPinName[pin], 0*(countWrap+1));\n\n}\n   \n#ifdef __cplusplus\n}\n#endif\n#elif defined(ARDUINO_ARCH_RENESAS_UNO)\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid MW_analogWrite(uint32_t pin, uint32_t value)\n{\n  analogWrite(pin,value);\n}\n\nvoid MW_setAnalogFrequency(uint16_t pin,uint16_t prescaler,uint16_t period)\n{\n   //analogWriteFrequency(pin,1/period);\n}\n   \n#ifdef __cplusplus\n}\n#endif\n\n\n#elif defined(ARDUINO_ARCH_AVR)                                                         /* AVR Targets */\n#include \"wiring_private.h\"\n#include \"pins_arduino.h\"\nvoid MW_analogWrite(uint32_t pin, uint32_t value)\n{\n    analogWrite(pin, value);\n}\n\nvoid MW_setAnalogFrequency(uint16_t pin,uint16_t prescaler,uint16_t period)\n{\n    switch(digitalPinToTimer(pin))\n    {\n        // XXX fix needed for atmega8\n        #if defined(TCCR0) && defined(COM00) && !defined(__AVR_ATmega8__)\n        case TIMER0A:\n            // connect pwm to pin on timer 0\n            sbi(TCCR0, COM00);\n            break;\n        #endif\n\n        #if defined(TCCR0A) && defined(COM0A1)\n        case TIMER0A:\n            // connect pwm to pin on timer 0, channel A\n            sbi(TCCR0A, COM0A1);\n            break;\n        #endif\n\n        #if defined(TCCR0A) && defined(COM0B1)\n        case TIMER0B:\n            // connect pwm to pin on timer 0, channel B\n            sbi(TCCR0A, COM0B1);\n            break;\n        #endif\n\n        #if defined(TCCR1A) && defined(TCCR1B) && defined(ICR1) && defined(COM1A1)\n        case TIMER1A:\n            TCCR1A = (TCCR1A & 0xFCU) | 2U;                               //WGM11 for PWM, Phase Correct. Mode 10\n            TCCR1B = (TCCR1B & 0xE0U) | 0x10U | prescaler;                //WGM13 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR1   = period;                                              //Period\n            sbi(TCCR1A, COM1A1);\n            break;\n        #endif\n\n        #if defined(TCCR1A) && defined(TCCR1B) && defined(ICR1) && defined(COM1B1)\n        case TIMER1B:\n            TCCR1A = (TCCR1A & 0xFCU) | 2U;                               //WGM11 for PWM, Phase Correct. Mode 10\n            TCCR1B = (TCCR1B & 0xE0U) | 0x10U | prescaler;                //WGM13 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR1   = period;                                              //Period\n            sbi(TCCR1A, COM1B1);\n            break;\n        #endif\n\n        #if defined(TCCR1A) && defined(TCCR1B) && defined(ICR1) && defined(COM1C1)\n        case TIMER1C:\n            // connect pwm to pin on timer 1, channel B\n            TCCR1A = (TCCR1A & 0xFCU) | 2U;                               //WGM11 for PWM, Phase Correct. Mode 10\n            TCCR1B = (TCCR1B & 0xE0U) | 0x10U | prescaler;                //WGM13 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR1   = period;                                              //Period\n            sbi(TCCR1A, COM1C1);\n            break;\n        #endif\n\n        #if defined(TCCR2) && defined(COM21)\n        case TIMER2:\n            // connect pwm to pin on timer 2\n            sbi(TCCR2, COM21);\n            break;\n        #endif\n\n        #if defined(TCCR2A) && defined(TCCR2B) && defined(COM2A1)\n        case TIMER2A:\n            // connect pwm to pin on timer 2, channel A\n            sbi(TCCR2A, COM2A1);\n            TCCR2B=TCCR2B & 0b11111000 | prescaler;                 //Prescaler\n            break;\n        #endif\n\n        #if defined(TCCR2A) && defined(TCCR2B) && defined(COM2B1)\n        case TIMER2B:\n            // connect pwm to pin on timer 2, channel B\n            sbi(TCCR2A, COM2B1);\n            TCCR2B=TCCR2B & 0b11111000 | prescaler;                 //Prescaler\n            break;\n        #endif\n\n        #if defined(TCCR3A) && defined(TCCR3B) && defined(ICR3) && defined(COM3A1)\n        case TIMER3A:\n            // connect pwm to pin on timer 3, channel A\n            TCCR3A = (TCCR3A & 0xFCU) | 2U;                               //WGM31 for PWM, Phase Correct. Mode 10\n            TCCR3B = (TCCR3B & 0xE0U) | 0x10U | prescaler;                //WGM33 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR3   = period;                                              //Period\n            sbi(TCCR3A, COM3A1);\n            break;\n        #endif\n\n        #if defined(TCCR3A) && defined(TCCR3B) && defined(ICR3) && defined(COM3B1)\n        case TIMER3B:\n            // connect pwm to pin on timer 3, channel B\n            TCCR3A = (TCCR3A & 0xFCU) | 2U;                               //WGM31 for PWM, Phase Correct. Mode 10\n            TCCR3B = (TCCR3B & 0xE0U) | 0x10U | prescaler;                //WGM33 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR3   = period;                                              //Period\n            sbi(TCCR3A, COM3B1);\n            break;\n        #endif\n\n        #if defined(TCCR3A) && defined(TCCR3B) && defined(ICR3) && defined(COM3C1)\n        case TIMER3C:\n            // connect pwm to pin on timer 3, channel C\n            TCCR3A = (TCCR3A & 0xFCU) | 2U;                               //WGM31 for PWM, Phase Correct. Mode 10\n            TCCR3B = (TCCR3B & 0xE0U) | 0x10U | prescaler;                //WGM33 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR3   = period;                                              //Period\n            sbi(TCCR3A, COM3C1);\n            break;\n        #endif\n\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D)  && defined(COM4A1) && defined(COM4A0)/* beginning of timer4 block for 32U4 and similar */\n        case TIMER4A:\n            TCCR4B = (TCCR4B & 0xf0) | prescaler;\n            OCR4C = period;\n            sbi(TCCR4A, COM4A1);\n            cbi(TCCR4A, COM4A0);\n            break;\n        #else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(ICR4) && defined(COM4A1)\n        case TIMER4A:\n            //connect pwm to pin on timer 4, channel A\n            TCCR4A = (TCCR4A & 0xFCU) | 2U;                               //WGM41 for PWM, Phase Correct. Mode 10\n            TCCR4B = (TCCR4B & 0xE0U) | 0x10U | prescaler;                //WGM43 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR4   = period;                                              //Period\n            sbi(TCCR4A, COM4A1);\n            break;\n        #endif\n        #endif\n\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D)  && defined(COM4B1) /* beginning of timer4 block for 32U4 and similar */\n        case TIMER4B:\n            TCCR4B = (TCCR4B & 0xf0) | prescaler;\n            OCR4C = period;\n            sbi(TCCR4A, COM4B1);\n            break;\n        #else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(ICR4) && defined(COM4B1)    \n        case TIMER4B:\n            // connect pwm to pin on timer 4, channel B\n            TCCR4A = (TCCR4A & 0xFCU) | 2U;                               //WGM41 for PWM, Phase Correct. Mode 10\n            TCCR4B = (TCCR4B & 0xE0U) | 0x10U | prescaler;                //WGM43 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR4   = period;                                              //Period\n            sbi(TCCR4A, COM4B1);\n            break;\n        #endif\n        #endif\n\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D)  && defined(COM4C1) /* beginning of timer4 block for 32U4 and similar */\n        case TIMER4C:\n            TCCR4B = (TCCR4B & 0xf0) | prescaler;\n            OCR4C = period;\n            sbi(TCCR4A, COM4C1);\n            break;\n        #else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(ICR4) && defined(COM4C1)    \n        case TIMER4C:\n            // connect pwm to pin on timer 4, channel C\n            TCCR4A = (TCCR4A & 0xFCU) | 2U;                               //WGM41 for PWM, Phase Correct. Mode 10\n            TCCR4B = (TCCR4B & 0xE0U) | 0x10U | prescaler;                //WGM43 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR4   = period;                                              //Period\n            sbi(TCCR4A, COM4C1);\n            break;\n        #endif\n        #endif\n\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D)  && defined(COM4D1) && defined(COM4D0)\t/* beginning of timer4 block for 32U4 and similar */\n        case TIMER4D:\n            TCCR4B = (TCCR4B & 0xf0) | prescaler;\n            OCR4C = period;\n            // connect pwm to pin on timer 4, channel D\n            sbi(TCCR4C, COM4D1);\n            cbi(TCCR4C, COM4D0);\n        #else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */\n        #if defined(TCCR4C) && defined(COM4D1)\n        case TIMER4D:\t\t\t\t\n            // connect pwm to pin on timer 4, channel D\n            sbi(TCCR4C, COM4D1);\n            #if defined(COM4D0)\t\t// only used on 32U4\n            cbi(TCCR4C, COM4D0);\n            #endif\n            break;\n        #endif\n        #endif\n\n        #if defined(TCCR5A) && defined(TCCR5B) && defined(ICR5) && defined(COM5A1)\n        case TIMER5A:\n            // connect pwm to pin on timer 5, channel A\n            TCCR5A = (TCCR5A & 0xFCU) | 2U;                               //WGM51 for PWM, Phase Correct. Mode 10\n            TCCR5B = (TCCR5B & 0xE0U) | 0x10U | prescaler;                //WGM53 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR5   = period;                                              //Period\n            sbi(TCCR5A, COM5A1);\n            break;\n        #endif\n\n        #if defined(TCCR5A) && defined(TCCR5B) && defined(ICR5) && defined(COM5B1)\n        case TIMER5B:\n            // connect pwm to pin on timer 5, channel B\n            TCCR5A = (TCCR5A & 0xFCU) | 2U;                               //WGM51 for PWM, Phase Correct. Mode 10\n            TCCR5B = (TCCR5B & 0xE0U) | 0x10U | prescaler;                //WGM53 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR5   = period;                                              //Period\n            sbi(TCCR5A, COM5B1);\n            break;\n        #endif\n\n        #if defined(TCCR5A) && defined(TCCR5B) && defined(ICR5) && defined(COM5C1)\n        case TIMER5C:\n            // connect pwm to pin on timer 5, channel C\n            TCCR5A = (TCCR5A & 0xFCU) | 2U;                               //WGM51 for PWM, Phase Correct. Mode 10\n            TCCR5B = (TCCR5B & 0xE0U) | 0x10U | prescaler;                //WGM53 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR5   = period;                                              //Period\n            sbi(TCCR5A, COM5C1);\n            break;\n        #endif\n    }\n    digitalWrite(pin, LOW);\n}\n\n/*Enable PWM Match Interrupt*/\n/* This function covers these MCUs:\n* atmega32u4 -> TIMSK0,1,3,4\n* atmega2560 -> TIMSK0,1,2,3,4,5\n* atmega328p -> TIMSK0,1,2\n* Source: Register summary in datasheet\nIf support is added for a board which uses some other MCU, then this function needs to be updated\n*/\nvoid MW_EnablePWMMatchInterrupt(uint8_T pin){\n    switch(digitalPinToTimer(pin))\n    {\n        #if defined(TIMSK0) && defined(OCIE0A)\n        case TIMER0A: TIMSK0 |= (1 << OCIE0A); break;\n        #endif\n\n        #if defined(TIMSK0) && defined(OCIE0B)\n        case TIMER0B: TIMSK0 |= (1 << OCIE0B); break;\n        #endif\n\n        #if defined(TIMSK1) && defined(OCIE1A)\n        case TIMER1A: TIMSK1 |= (1 << OCIE1A); break;\n        #endif\n\n        #if defined(TIMSK1) && defined(OCIE1B)\n        case TIMER1B: TIMSK1 |= (1 << OCIE1B); break;\n        #endif\n\n        #if defined(TIMSK1) && defined(OCIE1C)\n        case TIMER1C: TIMSK1 |= (1 << OCIE1C); break;\n        #endif\n\n        #if defined(TIMSK2) && defined(OCIE2A)\n        case TIMER2A: TIMSK2 |= (1 << OCIE2A); break;\n        #endif\n\n        #if defined(TIMSK2) && defined(OCIE2B)\n        case TIMER2B: TIMSK2 |= (1 << OCIE2B); break;\n        #endif\n\t\t\n        #if defined(TIMSK3) && defined(OCIE3A)\n        case TIMER3A: TIMSK3 |= (1 << OCIE3A); break;\n        #endif\n\n        #if defined(TIMSK3) && defined(OCIE3B)\n        case TIMER3B: TIMSK3 |= (1 << OCIE3B); break;\n        #endif\n\n        #if defined(TIMSK3) && defined(OCIE3C)\n        case TIMER3C: TIMSK3 |= (1 << OCIE3C); break;\n        #endif\n\t\t\n        #if defined(TIMSK4) && defined(OCIE4A)\n        case TIMER4A: TIMSK4 |= (1 << OCIE4A); break;\n        #endif\n\n        #if defined(TIMSK4) && defined(OCIE4B)\n        case TIMER4B: TIMSK4 |= (1 << OCIE4B); break;\n        #endif\n\n        #if defined(TIMSK4) && defined(OCIE4C)\n        case TIMER4C: TIMSK4 |= (1 << OCIE4C); break;\n        #endif\n\n        #if defined(TIMSK4) && defined(OCIE4D)\n        case TIMER4D: TIMSK4 |= (1 << OCIE4D); break;\n        #endif\n\t\t\n        #if defined(TIMSK5) && defined(OCIE5A)\n        case TIMER5A: TIMSK5 |= (1 << OCIE5A); break;\n        #endif\n\n        #if defined(TIMSK5) && defined(OCIE5B)\n        case TIMER5B: TIMSK5 |= (1 << OCIE5B); break;\n        #endif\n\n        #if defined(TIMSK5) && defined(OCIE5C)\n        case TIMER5C: TIMSK5 |= (1 << OCIE5C); break;\n        #endif\n    }\n}\n\n/*Enable PWM Overflow Interrupt*/\nvoid MW_EnablePWMOverflowInterrupt(uint8_T pin){\n    switch(digitalPinToTimer(pin))\n    {\n        #if defined(TIMSK0) && defined(TOIE0)\n        case TIMER0A: TIMSK0 |= (1 << TOIE0); break;\n        #endif\n\n        #if defined(TIMSK0) && defined(TOIE0)\n        case TIMER0B: TIMSK0 |= (1 << TOIE0); break;\n        #endif\n\n        #if defined(TIMSK1) && defined(TOIE1)\n        case TIMER1A: TIMSK1 |= (1 << TOIE1); break;\n        #endif\n\n        #if defined(TIMSK1) && defined(TOIE1)\n        case TIMER1B: TIMSK1 |= (1 << TOIE1); break;\n        #endif\n\n        #if defined(TIMSK1) && defined(TOIE1)\n        case TIMER1C: TIMSK1 |= (1 << TOIE1); break;\n        #endif\n\n        #if defined(TIMSK2) && defined(TOIE2)\n        case TIMER2A: TIMSK2 |= (1 << TOIE2); break;\n        #endif\n\n        #if defined(TIMSK2) && defined(TOIE2)\n        case TIMER2B: TIMSK2 |= (1 << TOIE2); break;\n        #endif\n\t\t\n        #if defined(TIMSK3) && defined(TOIE3)\n        case TIMER3A: TIMSK3 |= (1 << TOIE3); break;\n        #endif\n\n        #if defined(TIMSK3) && defined(TOIE3)\n        case TIMER3B: TIMSK3 |= (1 << TOIE3); break;\n        #endif\n\n        #if defined(TIMSK3) && defined(TOIE3)\n        case TIMER3C: TIMSK3 |= (1 << TOIE3); break;\n        #endif\n\t\t\n        #if defined(TIMSK4) && defined(TOIE4)\n        case TIMER4A: TIMSK4 |= (1 << TOIE4); break;\n        #endif\n\n        #if defined(TIMSK4) && defined(TOIE4)\n        case TIMER4B: TIMSK4 |= (1 << TOIE4); break;\n        #endif\n\n        #if defined(TIMSK4) && defined(TOIE4)\n        case TIMER4C: TIMSK4 |= (1 << TOIE4); break;\n        #endif\n\n        #if defined(TIMSK4) && defined(TOIE4)\n        case TIMER4D: TIMSK4 |= (1 << TOIE4); break;\n        #endif\n\t\t\n        #if defined(TIMSK5) && defined(TOIE5)\n        case TIMER5A: TIMSK5 |= (1 << TOIE5); break;\n        #endif\n\n        #if defined(TIMSK5) && defined(TOIE5)\n        case TIMER5B: TIMSK5 |= (1 << TOIE5); break;\n        #endif\n\n        #if defined(TIMSK5) && defined(TOIE5)\n        case TIMER5C: TIMSK5 |= (1 << TOIE5); break;\n        #endif\n    }\n}\n\n#elif defined(ARDUINO_ARCH_SAM)                                                         /* SAM Targets */\n#include \"Arduino.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    \nstatic int _writeResolution = 8;\nstatic uint8_t PWMEnabled = 0;\nstatic uint8_t TCChanEnabled[] = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n\nstatic inline uint32_t mapResolution(uint32_t value, uint32_t from, uint32_t to) {\n\tif (from == to)\n\t\treturn value;\n\tif (from > to)\n\t\treturn value >> (from-to);\n\telse\n\t\treturn value << (to-from);\n}\n\nstatic void TC_SetCMR_ChannelA(Tc *tc, uint32_t chan, uint32_t v)\n{\n\ttc->TC_CHANNEL[chan].TC_CMR = (tc->TC_CHANNEL[chan].TC_CMR & 0xFFF0FFFF) | v;\n}\n\nstatic void TC_SetCMR_ChannelB(Tc *tc, uint32_t chan, uint32_t v)\n{\n\ttc->TC_CHANNEL[chan].TC_CMR = (tc->TC_CHANNEL[chan].TC_CMR & 0xF0FFFFFF) | v;\n}\n\nvoid MW_analogWrite(uint32_t ulPin, uint32_t ulValue)\n{\n\tuint32_t attr = g_APinDescription[ulPin].ulPinAttribute;\n\n\tif ((attr & PIN_ATTR_ANALOG) == PIN_ATTR_ANALOG) {\n\t\tEAnalogChannel channel = g_APinDescription[ulPin].ulADCChannelNumber;\n\t\tif (channel == DA0 || channel == DA1) {\n\t\t\tuint32_t chDACC = ((channel == DA0) ? 0 : 1);\n\t\t\tif (dacc_get_channel_status(DACC_INTERFACE) == 0) {\n\t\t\t\t/* Enable clock for DACC_INTERFACE */\n\t\t\t\tpmc_enable_periph_clk(DACC_INTERFACE_ID);\n\n\t\t\t\t/* Reset DACC registers */\n\t\t\t\tdacc_reset(DACC_INTERFACE);\n\n\t\t\t\t/* Half word transfer mode */\n\t\t\t\tdacc_set_transfer_mode(DACC_INTERFACE, 0);\n\n\t\t\t\t/* Power save:\n\t\t\t\t * sleep mode  - 0 (disabled)\n\t\t\t\t * fast wakeup - 0 (disabled)\n\t\t\t\t */\n\t\t\t\tdacc_set_power_save(DACC_INTERFACE, 0, 0);\n\t\t\t\t/* Timing:\n\t\t\t\t * refresh        - 0x08 (1024*8 dacc clocks)\n\t\t\t\t * max speed mode -    0 (disabled)\n\t\t\t\t * startup time   - 0x10 (1024 dacc clocks)\n\t\t\t\t */\n\t\t\t\tdacc_set_timing(DACC_INTERFACE, 0x08, 0, 0x10);\n\n\t\t\t\t/* Set up analog current */\n\t\t\t\tdacc_set_analog_control(DACC_INTERFACE, DACC_ACR_IBCTLCH0(0x02) |\n\t\t\t\t\t\t\t\t\t\t\tDACC_ACR_IBCTLCH1(0x02) |\n\t\t\t\t\t\t\t\t\t\t\tDACC_ACR_IBCTLDACCORE(0x01));\n\t\t\t}\n\n\t\t\t/* Disable TAG and select output channel chDACC */\n\t\t\tdacc_set_channel_selection(DACC_INTERFACE, chDACC);\n\n\t\t\tif ((dacc_get_channel_status(DACC_INTERFACE) & (1 << chDACC)) == 0) {\n\t\t\t\tdacc_enable_channel(DACC_INTERFACE, chDACC);\n\t\t\t}\n\n\t\t\t// Write user value\n\t\t\tulValue = mapResolution(ulValue, _writeResolution, DACC_RESOLUTION);\n\t\t\tdacc_write_conversion_data(DACC_INTERFACE, ulValue);\n\t\t\twhile ((dacc_get_interrupt_status(DACC_INTERFACE) & DACC_ISR_EOC) == 0);\n\t\t\treturn;\n\t\t}\n\t}\n    \n    if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM) {\n        uint32_t chan = g_APinDescription[ulPin].ulPWMChannel;\n\t\t//ulValue = mapResolution(ulValue, _writeResolution, PWM_RESOLUTION);\n\t\tPWMC_SetDutyCycle(PWM_INTERFACE, chan, ulValue);\n\t\treturn;\n\t}\n\n\tif ((attr & PIN_ATTR_TIMER) == PIN_ATTR_TIMER) {\n\t\t// Setup Timer for this pin\n\t\tETCChannel channel = g_APinDescription[ulPin].ulTCChannel;\n\t\tstatic const uint32_t channelToChNo[] = { 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2 };\n\t\tstatic const uint32_t channelToAB[]   = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 };\n\t\tstatic Tc *channelToTC[] = {\n\t\t\tTC0, TC0, TC0, TC0, TC0, TC0,\n\t\t\tTC1, TC1, TC1, TC1, TC1, TC1,\n\t\t\tTC2, TC2, TC2, TC2, TC2, TC2 };\n\t\tstatic const uint32_t channelToId[] = { 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8 };\n\t\tuint32_t chNo = channelToChNo[channel];\n\t\tuint32_t chA  = channelToAB[channel];\n\t\tTc *chTC = channelToTC[channel];\n\t\tuint32_t interfaceID = channelToId[channel];\n\n\t\tif (ulValue == 0) {\n\t\t\tif (chA)\n\t\t\t\tTC_SetCMR_ChannelA(chTC, chNo, TC_CMR_ACPA_CLEAR | TC_CMR_ACPC_CLEAR);\n\t\t\telse\n\t\t\t\tTC_SetCMR_ChannelB(chTC, chNo, TC_CMR_BCPB_CLEAR | TC_CMR_BCPC_CLEAR);\n\t\t} else {\n\t\t\tif (chA) {\n\t\t\t\tTC_SetRA(chTC, chNo, ulValue);\n\t\t\t\tTC_SetCMR_ChannelA(chTC, chNo, TC_CMR_ACPA_CLEAR | TC_CMR_ACPC_SET);\n\t\t\t} else {\n\t\t\t\tTC_SetRB(chTC, chNo, ulValue);\n\t\t\t\tTC_SetCMR_ChannelB(chTC, chNo, TC_CMR_BCPB_CLEAR | TC_CMR_BCPC_SET);\n\t\t\t}\n\t\t}\n\t\tif ((g_pinStatus[ulPin] & 0xF) != PIN_STATUS_PWM) {\n\t\t\tPIO_Configure(g_APinDescription[ulPin].pPort,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinType,\n\t\t\t\t\tg_APinDescription[ulPin].ulPin,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinConfiguration);\n\t\t\tg_pinStatus[ulPin] = (g_pinStatus[ulPin] & 0xF0) | PIN_STATUS_PWM;\n\t\t}\n\t\treturn;\n\t}\n\n\t// Defaults to digital write\n\tpinMode(ulPin, OUTPUT);\n\tulValue = mapResolution(ulValue, _writeResolution, 8);\n\tif (ulValue < 128)\n\t\tdigitalWrite(ulPin, LOW);\n\telse\n\t\tdigitalWrite(ulPin, HIGH);\n}\nvoid MW_setAnalogFrequency(uint16_t ulPin,uint16_t prescaler,uint16_t period)\n{\n    uint32_t attr = g_APinDescription[ulPin].ulPinAttribute;\n    if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM) {\n\t\tif (!PWMEnabled) {\n\t\t\t// PWM Startup code\n\t\t    pmc_enable_periph_clk(PWM_INTERFACE_ID);\n\t\t    PWMC_ConfigureClocks(PWM_FREQUENCY * PWM_MAX_DUTY_CYCLE, 0, VARIANT_MCK);\n\t\t\tPWMEnabled = 1;\n\t\t}\n\n\t\tuint32_t chan = g_APinDescription[ulPin].ulPWMChannel;\n\t\tif ((g_pinStatus[ulPin] & 0xF) != PIN_STATUS_PWM) {\n\t\t\t// Setup PWM for this pin\n\t\t\tPIO_Configure(g_APinDescription[ulPin].pPort,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinType,\n\t\t\t\t\tg_APinDescription[ulPin].ulPin,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinConfiguration);\n\t\t\tPWMC_ConfigureChannel(PWM_INTERFACE, chan, prescaler, 0, 0);\n\t\t\tPWMC_SetPeriod(PWM_INTERFACE, chan, period);\n\t\t\tPWMC_SetDutyCycle(PWM_INTERFACE, chan, 0);\n\t\t\tPWMC_EnableChannel(PWM_INTERFACE, chan);\n\t\t\tg_pinStatus[ulPin] = (g_pinStatus[ulPin] & 0xF0) | PIN_STATUS_PWM;\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((attr & PIN_ATTR_TIMER) == PIN_ATTR_TIMER) {\n\t\t// We use MCLK/2 as clock.\n\t\tconst uint32_t TC = period;\n\n\t\t// Setup Timer for this pin\n\t\tETCChannel channel = g_APinDescription[ulPin].ulTCChannel;\n\t\tstatic const uint32_t channelToChNo[] = { 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2 };\n\t\tstatic const uint32_t channelToAB[]   = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 };\n\t\tstatic Tc *channelToTC[] = {\n\t\t\tTC0, TC0, TC0, TC0, TC0, TC0,\n\t\t\tTC1, TC1, TC1, TC1, TC1, TC1,\n\t\t\tTC2, TC2, TC2, TC2, TC2, TC2 };\n\t\tstatic const uint32_t channelToId[] = { 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8 };\n\t\tuint32_t chNo = channelToChNo[channel];\n\t\tuint32_t chA  = channelToAB[channel];\n\t\tTc *chTC = channelToTC[channel];\n\t\tuint32_t interfaceID = channelToId[channel];\n\n\t\tif (!TCChanEnabled[interfaceID]) {\n\t\t\tpmc_enable_periph_clk(TC_INTERFACE_ID + interfaceID);\n\t\t\tTC_Configure(chTC, chNo,\n\t\t\t\tprescaler |\n\t\t\t\tTC_CMR_WAVE |         // Waveform mode\n\t\t\t\tTC_CMR_WAVSEL_UP_RC | // Counter running up and reset when equals to RC\n\t\t\t\tTC_CMR_EEVT_XC0 |     // Set external events from XC0 (this setup TIOB as output)\n\t\t\t\tTC_CMR_ACPA_CLEAR | TC_CMR_ACPC_CLEAR |\n\t\t\t\tTC_CMR_BCPB_CLEAR | TC_CMR_BCPC_CLEAR);\n\t\t\tTC_SetRC(chTC, chNo, TC);\n\t\t}\n\t\t\n\t\tif ((g_pinStatus[ulPin] & 0xF) != PIN_STATUS_PWM) {\n\t\t\tPIO_Configure(g_APinDescription[ulPin].pPort,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinType,\n\t\t\t\t\tg_APinDescription[ulPin].ulPin,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinConfiguration);\n\t\t\tg_pinStatus[ulPin] = (g_pinStatus[ulPin] & 0xF0) | PIN_STATUS_PWM;\n\t\t}\n\t\tif (!TCChanEnabled[interfaceID]) {\n\t\t\tTC_Start(chTC, chNo);\n\t\t\tTCChanEnabled[interfaceID] = 1;\n\t\t}\n\t\treturn;\n\t}\n}\n\n#ifdef __cplusplus\n}\n#endif\n#endif                                                                                  /* Architecture selection endif*/                                                                             \n\n#endif /*Rapid Accel condition check*/\n/* [EOF] */"},{"name":"MW_arduinoNanoRP2040_multitasking.c","type":"source","group":"legacy","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\target\\supportpackages\\arduinotarget\\scheduler\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2024 The MathWorks, Inc. */\n\n#if (defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO))\n\n#include \"mw_force_no_optimization.h\"\n#include \"arm_cortex_m_multitasking.h\"\n\n__attribute__ ((naked,aligned(4))) void arm_cortex_m_call_thread_with_context_switch(void (* isr_routine_ptr)(void)) {\n     __asm volatile (\"     push {r0, r1}\");\n     __asm volatile (\"     SUB SP, SP, #0x20\");\n     __asm volatile (\"     ADR R0,Call_isr_routine_in_thread_mode\");\n     __asm volatile (\"     NOP\");\n     __asm volatile (\"     STR R0,[SP, #24]\");\n     __asm volatile (\"     MOV R0,#0x01\");\n     __asm volatile (\"     LSL R0,#24\");\n     __asm volatile (\"     STR R0,[SP, #28]\");\n     __asm volatile (\"     MOV R0,#0x6\");\n     __asm volatile (\"     mvn r0, r0\");\n     __asm volatile (\"     MOV LR, R0\");\n     __asm volatile (\"     BX LR\");\n     __asm volatile (\"Call_isr_routine_in_thread_mode:\");\n     __asm volatile (\"     pop {r0, r1}\");\n     __asm volatile (\"     BLX R0\");\n     __asm volatile (\"     ISB\");\n     __asm volatile (\"     SVC #0\");\n     __asm volatile (\"Unknown_Execution:\");\n     __asm volatile (\"     B Unknown_Execution\");\n}\n/* SVC Interrupt service routine to restore the context: SVC_Handler*/\n\n__attribute__ ((naked,aligned(4))) void SVC_Handler(void) {\n     __asm volatile (\"     MOVS r0, #0x4\");\n     __asm volatile (\"     MOV r1, LR\");\n     __asm volatile (\"     TST r0, r1\");\n     __asm volatile (\"     BEQ stack_used_msp\");\n     __asm volatile (\"     MRS R0, PSP\");\n     __asm volatile (\"     B get_service_request\");\n     __asm volatile (\"stack_used_msp:\");\n     __asm volatile (\"     MRS R0, MSP\");\n     __asm volatile (\"get_service_request:\");\n     __asm volatile (\"     LDR R1, [R0, #24]\");\n     __asm volatile (\"     SUB R1, R1, #0x2\");\n     __asm volatile (\"     LDRB R0, [R1]\");\n     __asm volatile (\"     CMP R0, #0\");\n     __asm volatile (\"     BEQ svc_service_0\");\n     __asm volatile (\"     B Unknown_SVC_Request\");\n     __asm volatile (\"svc_service_0:\");\n     __asm volatile (\"     ADD SP, SP, #32\");\n     __asm volatile (\"     POP {R0, R1}\");\n     __asm volatile (\"     MSR APSR_nzcvq, R0\");\n     __asm volatile (\"     BX R1\");\n     __asm volatile (\"Unknown_SVC_Request:\");\n     __asm volatile (\"     B Unknown_SVC_Request\");\n}\n\n#else // RP2040 Connect\n\n#include \"mw_force_no_optimization.h\"\n#include \"arm_cortex_m_multitasking.h\"\n/* Re-entrant function for multi-tasking: arm_cortex_m_call_thread_with_context_switch*/\n\n__attribute__ ((naked,aligned(4))) void arm_cortex_m_call_thread_with_context_switch(void (* isr_routine_ptr)(void)) {\n     __asm volatile (\"     push {r0, r1}\");\n     __asm volatile (\"     SUB SP, SP, #0x20\");\n     __asm volatile (\"     ADR R0,Call_isr_routine_in_thread_mode\");\n     __asm volatile (\"     NOP\");\n     __asm volatile (\"     STR R0,[SP, #24]\");\n     __asm volatile (\"     MOV R0,#0x01\");\n     __asm volatile (\"     LSL R0,#24\");\n     __asm volatile (\"     STR R0,[SP, #28]\");\n     __asm volatile (\"     MOV R0,#0x6\");\n     __asm volatile (\"     mvn r0, r0\");\n     __asm volatile (\"     MOV LR, R0\");\n     __asm volatile (\"     BX LR\");\n     __asm volatile (\"Call_isr_routine_in_thread_mode:\");\n     __asm volatile (\"     pop {r0, r1}\");\n     __asm volatile (\"     BLX R0\");\n     __asm volatile (\"     ISB\");\n     __asm volatile (\"     SVC #255\");\n     __asm volatile (\"Unknown_Execution:\");\n     __asm volatile (\"     B Unknown_Execution\");\n}\n\n#endif //ARDUINO_RASPBERRY_PI_PICO_W"},{"name":"MW_arduino_digitalio.cpp","type":"source","group":"legacy","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"#ifndef MATLAB_MEX_FILE\n#include <Arduino.h>\n#include \"MW_arduino_digitalio.h\"\n#endif\n#include \"rtwtypes.h\"\n\n// Digital I/O initialization\nextern \"C\" void digitalIOSetup(uint8_T pin, uint8_T mode) \n{ \n    #ifndef MATLAB_MEX_FILE\n    // mode = 0: Input\n    // mode = 1: Output\n    // mode = 2: Input pullup\n    if (mode==0) {\n        pinMode(pin, INPUT);\n    }\n    else if (mode==1) {\n        pinMode(pin, OUTPUT);\n    }\n    else {\n        // mode = 2 is for input pullup\n        pinMode(pin, INPUT_PULLUP);\n    }\n    #endif\n}\n\n// Write a logic value to pin\nextern \"C\" void writeDigitalPin(uint8_T pin, boolean_T val)\n{\n    #ifndef MATLAB_MEX_FILE\n    if (val) {\n        digitalWrite(pin, HIGH);\n    } \n    else {\n        digitalWrite(pin, LOW);\n    }\n    #endif\n}\n\n// Read logical state of a digital pin\nextern \"C\" boolean_T readDigitalPin(uint8_T pin)\n{\n    #ifndef MATLAB_MEX_FILE\n    boolean_T ret;\n     \n    ret = (digitalRead(pin) == HIGH) ? 1:0;\n    return ret;\n    #else\n    return (boolean_T)0;\n    #endif\n}\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"MW_ArduinoHWInit.h\"\n#include \"arduinoARM_M0plus_RP2040_Scheduler.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE Raspberry Pi Pico (Arduino Compatible)\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_MAXCONTIGSAMPLES 10\n#define MW_CONNECTIONINFO_XCPONSERIAL_BAUDRATE codertarget.arduinobase.registry.getBaudRate\n#define MW_CONNECTIONINFO_XCPONSERIAL_COMPORT codertarget.arduinobase.internal.getExternalModeMexArgs('Serial')\n#define MW_CONNECTIONINFO_XCPONSERIAL_VERBOSE 0\n#define MW_EXTMODE_CONFIGURATION XCP on Serial\n#define MW_EXTMODE_COMPORTBAUD 921600\n#define MW_EXTMODE_TARGETPOLLINGTIMEMODE 0\n#define MW_EXTMODE_TARGETPOLLINGTIME 2\n#define MW_EXTMODE_USEREALTIMESTAMPLOGGING 0\n#define MW_RTOS Baremetal\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_RUNTIME_FORCEBUILDSTATICLIBRARY 0\n#define MW_RUNTIME_VERBOSEOUTPUT 0\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_PORT_SOURCE 2\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_COMPORT_SPECIFY 8\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_BAUD 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_SERIAL_PORT 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_PORT_SOURCE1 2\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_PORT_SOURCE2 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_COMPORT_SPECIFY 8\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_BAUD 8\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_BAUD_SPECIFY \n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_SERIAL_PORT 0\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_PORT_SOURCE1 2\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_PORT_SOURCE2 0\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_COMPORT_SPECIFY 8\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_BAUD -1\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_BAUD_SPECIFY \n#define MW_CONNECTEDIO_CONNECTEDIOMODE 0\n#define MW_CONNECTEDIO_ACTIONONOVERRUN 0\n#define MW_OVERRUNDETECTION_ENABLE_OVERRUN_DETECTION 0\n#define MW_OVERRUNDETECTION_DIGITAL_OUTPUT_TO_SET_ON_OVERRUN 6\n#define MW_ANALOGINREFVOLTAGE_ANALOG_INPUT_REFERENCE_VOLTAGE 0.000000\n#define MW_SERIAL_SERIAL0_BAUD_RATE 8\n#define MW_SERIAL_SERIAL0_BAUD_SPECIFY 921600\n#define MW_SERIAL_SERIAL0_CONFIG 3\n#define MW_SERIAL_SERIAL1_BAUD_RATE 8\n#define MW_SERIAL_SERIAL1_BAUD_SPECIFY 921600\n#define MW_SERIAL_SERIAL1_CONFIG 3\n#define MW_SERIAL_SERIAL2_BAUD_RATE 8\n#define MW_SERIAL_SERIAL2_BAUD_SPECIFY 921600\n#define MW_SERIAL_SERIAL2_CONFIG 3\n#define MW_I2C_I2C0BUSSPEEDHZ 100000\n#define MW_I2C_I2C1BUSSPEEDHZ 100000\n#define MW_SPI_SPI0_CLOCK_OUT_FREQUENCY 1\n#define MW_SPI_SPI0_MODE 0\n#define MW_SPI_SPI0_BITORDER 0\n#define MW_SPI_SPI1_CLOCK_OUT_FREQUENCY 1\n#define MW_SPI_SPI1_MODE 0\n#define MW_SPI_SPI1_BITORDER 0\n#define MW_PWM_PWM_DEFAULT_FREQUENCY 200000\n#define MW_IOBLOCKSMODE deployed\n#define MW_DATAVERSION 2016.02\n#define MW_DASHBOARDCODEGENINFO_ENABLECODEGEN 0\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_CODEGEN 1\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_BLOCKCLASS codertarget.targetHiddenBlkInsert.internal.circularGauge\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_REGFCN codertarget.arduinobase.blocks.registerDashboardBlk\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_VALIDATEFCN codertarget.targetHiddenBlkInsert.internal.isDashboardBlockCodegenEnabled\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_CODEGEN 1\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_BLOCKCLASS codertarget.targetHiddenBlkInsert.internal.lcdTextDisplay\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_REGFCN codertarget.arduinobase.blocks.registerDashboardBlk\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_VALIDATEFCN codertarget.targetHiddenBlkInsert.internal.isDashboardBlockCodegenEnabled\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_CODEGEN 1\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_BLOCKCLASS codertarget.targetHiddenBlkInsert.internal.pushButton\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_REGFCN codertarget.arduinobase.blocks.registerDashboardBlk\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_VALIDATEFCN codertarget.targetHiddenBlkInsert.internal.isDashboardBlockCodegenEnabled\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"arduinoARM_M0plus_RP2040_Scheduler.cpp","type":"source","group":"legacy","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\target\\supportpackages\\arduinotarget\\scheduler\\src","tag":"","groupDisplay":"Other files","code":"/* Arduino ARM M0+ Bareboard RP2040 scheduler\n *\n * Copyright 2024 The MathWorks, Inc.\n */\n\n#include \"Arduino.h\"\n#include \"arduinoARM_M0plus_RP2040_Scheduler.h\"\n\n/* Multi tasking related header file */\n#include \"arm_cortex_m_multitasking.h\"\n\nextern volatile int IsrOverrun;\nunsigned long oldtime = 0L;\nunsigned long actualtime;\n\n#if (defined(MW_SCHEDULERCOUNTER) &&  (MW_SCHEDULERCOUNTER > 1))\n   #if (MW_SCHEDULERCOUNTER >= 65536)\n      volatile uint32_t scheduler_counter = 0;\n    #elif (MW_SCHEDULERCOUNTER >= 256)\n      volatile uint16_t scheduler_counter = 0;\n    #else\n      volatile uint8_t scheduler_counter = 0;\n    #endif\n#endif\n\n#ifndef _MW_ARDUINO_LOOP_\n\nvoid arm_alarm(uint8_t alarmId,uint32_t alarmResolution) {\n    uint64_t target = timer_hw->timerawl + alarmResolution;\n    timer_hw->alarm[alarmId] = (uint32_t) target;\n}\n\n/*\n * Call the rt_Onestep function when the timer interrupt hits     \n *\n */\nstatic void Scheduler_Isr(void)\n{\n    DISABLE_SCHEDULER_INT();\n    /* DSB (Data Synchronization Barrier) operation will complete when all \n     * explicit memory accesses before this instruction have completed.\n     * No instructions after the DSB will be executed until the DSB\n     * instruction has completed, that is, when all of the pending accesses\n     * have completed. */\n   // __DSB();\n\n    /* ISB (Instruction Synchronization Barrier)flushes the pipeline in\n     * the processor, so that all instructions following the ISB are\n     * fetched from cache or memory, after the instruction has been\n     * completed. It ensures that changes to the system, for example\n     * the MPU, take immediate effect.*/\n   // __ISB();\n        \n    #if (defined(MW_SCHEDULERCOUNTER) && (MW_SCHEDULERCOUNTER > 1))\n      if ((++scheduler_counter) == MW_SCHEDULERCOUNTER) {\n         scheduler_counter = 0;\n    #endif\n    \n    #ifdef _RTT_OVERRUN_DIGITAL_PIN_\n        if (IsrOverrun == 1)\n        {\n          /* Overrun detected */\n          digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n        }\n    #endif\n    \n\trt_OneStep();\n    \n    #if (defined(MW_SCHEDULERCOUNTER) && (MW_SCHEDULERCOUNTER > 1))\n      }\n    #endif\n\n    ENABLE_SCHEDULER_INT();\n} \n\n#endif\n\nextern \"C\" void configureArduinoARM_M0plus_RP2040_Alarm(void)\n{\n    #if defined(_ARDUINO_RP2040_ALARM_1_)\n    Setup_SchedulerAlarm(ID_FOR_ALARM1, TIMER_ID_FOR_ALARM1, IRQn_FOR_ALARM1, MW_ALARM_RESOLUTION);\n    \n    #if (defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO))\n    /* Set SVC to least priority */\n    NVIC_SetPriority((IRQn_Type)(-5), 0xFFU);\n    exception_set_exclusive_handler(SVCALL_EXCEPTION, SVC_Handler);\n    #endif\n\n    #endif\n}\n\n#ifndef _MW_ARDUINO_LOOP_\n#if defined(_ARDUINO_RP2040_ALARM_1_)\n#if (defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO))\nvoid SchedulerAlarm_Handler(void)\n#else \n__attribute__ ((naked)) void SchedulerAlarm_Handler(void)\n#endif\n{\n    /* Multi tasking, enable re-entrancy */\n\n    #if !(defined(ARDUINO_RASPBERRY_PI_PICO_W) || defined(ARDUINO_RASPBERRY_PI_PICO))\n    /* Naked functions need the following prolog */\n    ARM_CORTEX_M_PUSH_THREADS_PSR_AND_RET_ADDR();\n    #endif\n\n    /* Needs to be called to reenable the Timer interrupt */\n    hw_clear_bits(&timer_hw->intr, 1u << ID_FOR_ALARM1);\n    arm_alarm(ID_FOR_ALARM1,MW_ALARM_RESOLUTION);\n\n    /* Context switch to rt_OneStep() */\n    arm_cortex_m_call_thread_with_context_switch(Scheduler_Isr);\n}\n#endif\n#endif\n\n\nvoid Setup_SchedulerAlarm(uint8_t alarmId, int timerIdforAlarm, IRQn_Type irqn, uint32_t alarmResolution)\n{\n    #ifndef _MW_ARDUINO_LOOP_\n    /* Configure interrupt request*/\n    NVIC_DisableIRQ(irqn);\n    NVIC_ClearPendingIRQ(irqn);\n    NVIC_SetPriority(irqn,(1<<__NVIC_PRIO_BITS) - 1);\n\n    /* Setup alarm based interrupt */\n    hw_set_bits(&timer_hw->inte, 1u << alarmId);\n    irq_set_exclusive_handler(timerIdforAlarm, SchedulerAlarm_Handler);\n    arm_alarm(ID_FOR_ALARM1,MW_ALARM_RESOLUTION);\n\n    /*Enable interrupt request */\n    NVIC_EnableIRQ(irqn);\n    #endif\n}\n\nboolean disable_rt_OneStep(void)\n{\n    boolean t_return = 0U;\n#ifndef _MW_ARDUINO_LOOP_\n    #if defined(_ARDUINO_RP2040_ALARM_1_)\n    // Disable the alarm \n    //hw_clear_bits(&timer_hw->inte, 1u << ID_FOR_ALARM1);\n    NVIC_DisableIRQ(IRQn_FOR_ALARM1);\n    #endif\n#endif\n    return t_return;\n}\n\nvoid enable_rt_OneStep(void)\n{\n#ifndef _MW_ARDUINO_LOOP_\n    #if defined(_ARDUINO_RP2040_ALARM_1_)\n    // re-enable the alarm\n    hw_clear_bits(&timer_hw->intr, 1u << ID_FOR_ALARM1);\n    arm_alarm(ID_FOR_ALARM1,MW_ALARM_RESOLUTION);\n    NVIC_EnableIRQ(IRQn_FOR_ALARM1);\n    #endif\n#endif\n}\n\nboolean MW_Arduino_Loop(void)\n{\n    boolean ret = 0;\n\n#ifdef _MW_ARDUINO_LOOP_\n#if (defined(MW_ARDUINO_MICROS))\n    actualtime = micros();\n#else\n    actualtime = millis();\n#endif\n\n    if ((unsigned long) (actualtime - oldtime) >= MW_ARDUINO_STEP_SIZE)\n    {\n        oldtime = actualtime;\n        \n#ifdef _RTT_OVERRUN_DIGITAL_PIN_\n        if (IsrOverrun == 1)\n        {\n            // Overrun detected\n            digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n        }\n#endif\n        rt_OneStep();\n    }\n#endif\n        \n    ret = 1;\n    return ret;\n}\n\n// LocalWords:  Bareboard Onestep DSB ISB MPU RTC PRESCALER SVC Prescalar CTRLA snyc'd GCLK TCx\n// LocalWords:  prescaler XCP\n"},{"name":"io_wrappers.cpp","type":"source","group":"legacy","path":"C:\\Users\\burly\\OneDrive\\Desktop\\matlab_buck_converter_EEE489\\buck_converter_w_feedback_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2024b\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Wrappers to make I/O functions available with C linkage. This allows C++\n* methods to be called from C code.\n*\n* Copyright 2011-2024 The MathWorks, Inc. */\n\n#include <inttypes.h>\n#include \"Arduino.h\"\n#include \"rtwtypes.h\"\n\n#if (defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)) || (defined(_RTT_UDP_) && (_RTT_UDP_ != 0)) || (defined(_RTT_TCP_) && (_RTT_TCP_ != 0) || defined(_RTT_THINGSPEAK_))\n#include <Ethernet.h>\n#include <EthernetUdp.h>\n#include <SPI.h>\n#endif\n\n#if defined(ARDUINO_ARM_CORTEX_M0_PLUS)\nextern \"C\" void __libc_init_array(void);\n#endif\n\nextern \"C\" {\n    void __cxa_pure_virtual(void);\n}\n\nextern \"C\" void Serial_begin(int port, long r, int c)\n{\n    static int serialInit=0;\n    #if !(defined(ESP_PLATFORM))\n    serialInit=0;   //Reset serialInit flag for all targets except ESP32\n    #endif\n    #if defined(ARDUINO_ARCH_SAM)\n    UARTClass::UARTModes config = UARTClass::UARTModes(c);\n    #else\n    int config = c;\n    #endif\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            if(serialInit & 1)return;\n            serialInit |= 1;\n            #if defined(ESP_PLATFORM)\n            Serial.begin(r,config,_RTT_RX_PIN_SERIAL0_,_RTT_TX_PIN_SERIAL0_);\n            #elif (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial.begin(r);\n            #else\n            Serial.begin(r,config);\n            #endif\n            break;\n        case 1:\n            if(serialInit & 2)return;\n            serialInit |= 2;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            #if defined(ESP_PLATFORM)\n            Serial1.begin(r,config,_RTT_RX_PIN_SERIAL1_,_RTT_TX_PIN_SERIAL1_);\n            #elif (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial1.begin(r);\n            #else\n            Serial1.begin(r,config);\n            #endif\n            #endif\n            break;\n        case 2:\n            if(serialInit & 4)return;\n            serialInit |= 4;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            #if defined(ESP_PLATFORM)\n            Serial2.begin(r,config,_RTT_RX_PIN_SERIAL2_,_RTT_TX_PIN_SERIAL2_);\n            #elif (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial2.begin(r);\n            #else\n            Serial2.begin(r,config);\n            #endif\n            #endif\n            break;\n        case 3:\n            if(serialInit & 8)return;\n            serialInit |= 8;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial3.begin(r);\n            #else\n            Serial3.begin(r,config);\n            #endif\n            #endif\n\n            break;\n        case 4:\n            if(serialInit & 16)return;\n            serialInit |= 16;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 5)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial4.begin(r);\n            #else\n            Serial4.begin(r,config);\n            #endif\n            #endif\n            break;\n       case 5:\n            if(serialInit & 32)return;\n            serialInit |= 32;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 6)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial5.begin(r);\n            #else\n            Serial5.begin(r,config);\n            #endif\n            #endif\n\n            break;\n       case 6:\n            if(serialInit & 64)return;\n            serialInit |= 64;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 7)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial6.begin(r);\n            #else\n            Serial6.begin(r,config);\n            #endif\n            #endif\n\n            break;\n        case 7:\n            if(serialInit & 128)return;\n            serialInit |= 128;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 8)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial7.begin(r);\n            #else\n            Serial7.begin(r,config);\n            #endif\n            #endif\n      case 8:\n            if(serialInit & 256)return;\n            serialInit |= 256;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 9)\n            #if (defined(ARDUINO_TEENSY41))\n            Serial8.begin(r);\n            #else\n            Serial8.begin(r,config);\n            #endif\n            #endif\n\n            break;\n\n            break;\n    }\n    #else\n    if(serialInit & 1)return;\n    serialInit |= 1;\n    Serial.begin(r,SERIAL_8N1);\n    #endif\n}\n\nextern \"C\" void Serial_read(int port, int showOutStatus, uint8_t *outData, int16_t *outStatus)\n{\n    int libFcnOutput;\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            libFcnOutput = Serial.read();\n            break;\n        case 1:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            libFcnOutput = Serial1.read();\n            #endif\n            break;\n        case 2:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            libFcnOutput = Serial2.read();\n            #endif\n            break;\n        case 3:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            libFcnOutput = Serial3.read();\n            #endif\n            break;\n        case 4:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 5)\n            libFcnOutput = Serial4.read();\n            #endif\n            break;\n        case 5:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 6)\n            libFcnOutput = Serial5.read();\n            #endif\n            break;\n        case 6:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 7)\n            libFcnOutput = Serial6.read();\n            #endif\n            break;\n       case 7:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 8)\n            libFcnOutput = Serial7.read();\n            #endif\n            break;\n       case 8:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 9)\n            libFcnOutput = Serial8.read();\n            #endif\n            break;\n    }\n    #else\n    libFcnOutput = Serial.read();\n    #endif\n    *outData = (uint8_t) libFcnOutput;\n    *outStatus = (libFcnOutput != -1);\n}\n\nextern \"C\" void Serial_write(int port, uint8_t * c, size_t s)\n{\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            Serial.write(c, s);\n            break;\n        case 1:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            Serial1.write(c, s);\n            #endif\n            break;\n        case 2:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            Serial2.write(c, s);\n            #endif\n            break;\n        case 3:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            Serial3.write(c, s);\n            #endif\n            break;\n        case 4:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 5)\n            Serial4.write(c, s);\n            #endif\n            break;\n        case 5:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 6)\n            Serial5.write(c, s);\n            #endif\n            break;\n        case 6:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 7)\n            Serial6.write(c, s);\n            #endif\n            break;\n        case 7:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 8)\n            Serial7.write(c, s);\n            #endif\n            break;\n        case 8:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 9)\n            Serial8.write(c, s);\n            #endif\n            break;\n    }\n    #else\n    Serial.write(c, s);\n    #endif\n}\n\n#if _RTT_UDP_ != 0\nEthernetUDP Udp[_RTT_UDP_];\nIPAddress localIpAddress(_RTT_Local_IP1, _RTT_Local_IP2, _RTT_Local_IP3, _RTT_Local_IP4);\nbyte mac[] = { _RTT_Local_MAC1, _RTT_Local_MAC2, _RTT_Local_MAC3, _RTT_Local_MAC4, _RTT_Local_MAC5, _RTT_Local_MAC6 };\nunsigned int localport[_RTT_UDP_] = {_RTT_UDP_LOCAL_PORT_ORDERED};\nint configureSuccess;\nint trialcount=0;\nextern \"C\" uint8_t MW_EthernetAndUDPBegin(uint8_t udpindex, uint32_t localPort)\n{\n    static int only_one_ethernet_begin;\n    if (only_one_ethernet_begin==0)\n    {\n        #if (defined(_RTT_DISABLE_Ethernet_DHCP_) && (_RTT_DISABLE_Ethernet_DHCP_ !=0))\n        Ethernet.begin(mac, localIpAddress);\n        configureSuccess = 1;\n        #else\n        configureSuccess = Ethernet.begin(mac);\n        #endif\n        only_one_ethernet_begin++;\n\n        for(trialcount=0;trialcount<5;trialcount++)\n        {\n            if(Serial)\n            {\n                break;\n            }else\n            {\n                delay(1000);\n            }\n        }\n        // Depending on if the IP address assignment using DHCP has been successful or not,\n        // send the appropriate information back to the host.\n        // If External mode over TCP/IP or Wifi, do not print this Info. Information of IP address will be printed as\n        // a part of rtiostream_open\n        #if (!(defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)))\n        if (configureSuccess==1)\n        {\n            if(Ethernet.localIP()[0] == 0 || Ethernet.localIP()[0] == 255)\n            {\n                /*Tried to assign Static IP, failed due to one of the following reasons :\n                * 1. Ethernet shield is not connected properly with Arduino.\n                * 2. Ethernet shield is not connected to a network.\n                **/\n                Serial.println(\"<<<IP address: Failed to configure.>>>\");\n            }\n            else\n            {\n                // If the Configuration is successful, relay back the assigned IP address.\n                Serial.print(\"<<<IP address: \");\n                for (byte thisByte = 0; thisByte < 4; thisByte++)\n                {\n                    // Print the value of each byte of the IP address:\n                    Serial.print(Ethernet.localIP()[thisByte], DEC);\n                    if (thisByte<3)\n                    {\n                        Serial.print(\".\");\n                    }\n                }\n                Serial.println(\">>>\");\n            }\n        }\n        else\n        {\n            // If the Configuration failed,relay back the error message.\n            Serial.println(\"<<<IP address: Failed to configure.>>>\");\n        }\n        Serial.flush();\n        #endif\n    }\n    return (Udp[udpindex].begin(localport[udpindex]));\n}\n\nextern \"C\" int MW_UDPFinalWrite(uint8_t udpindex, uint8_t data, uint8_t remoteIPOctect1,uint8_t remoteIPOctect2,uint8_t remoteIPOctect3,uint8_t remoteIPOctect4, uint32_t remoteport)\n{\n    IPAddress remoteIpAddress(remoteIPOctect1,remoteIPOctect2, remoteIPOctect3, remoteIPOctect4);\n    Udp[udpindex].beginPacket(remoteIpAddress, remoteport);\n    Udp[udpindex].write(data);\n    return(Udp[udpindex].endPacket());\n}\n\nextern \"C\" void MW_UDPFinalRead(uint8_t udpindex, uint8_t *data, int32_t *outStatus)\n{\n    int packetSize = Udp[udpindex].parsePacket();\n    if(packetSize)\n    {\n        int libFcnOutput;\n        libFcnOutput = Udp[udpindex].read();\n        *data = (uint8_t) libFcnOutput;\n        *outStatus = (libFcnOutput != -1);\n    }\n\n    else\n    {\n        //When the client is not connected the status flag is accordingly toggled.\n        *outStatus = 0;\n    }\n}\n#endif\n\n#if defined(_RTT_THINGSPEAK_) || (_RTT_TCP_ != 0)\nIPAddress localIpAddress(_RTT_Local_IP1, _RTT_Local_IP2, _RTT_Local_IP3, _RTT_Local_IP4);\nbyte mac[] = { _RTT_Local_MAC1, _RTT_Local_MAC2, _RTT_Local_MAC3, _RTT_Local_MAC4, _RTT_Local_MAC5, _RTT_Local_MAC6 };\nint configureSuccess;\nint trialcount;\n#if _RTT_TCP_ != 0\nEthernetServer server[_RTT_TCP_] = {_RTT_TCP_SERVER_PORT_ORDERED};\n#endif\nextern \"C\" void MW_EthernetAndTCPServerBegin(uint8_t tcpindex, uint32_t serverport)\n{\n    static int only_one_tcp_server_and_ethernet_begin = 0;\n\n    if (only_one_tcp_server_and_ethernet_begin==0)\n    {\n        #if (defined(_RTT_DISABLE_Ethernet_DHCP_) && (_RTT_DISABLE_Ethernet_DHCP_ !=0))\n        Ethernet.begin(mac, localIpAddress);\n        configureSuccess = 1;\n        #else\n        configureSuccess = Ethernet.begin(mac);\n        #endif\n        only_one_tcp_server_and_ethernet_begin++;\n\n        for(trialcount=0;trialcount<5;trialcount++)\n        {\n            if(Serial)\n            {\n                break;\n            }else\n            {\n                delay(1000);\n            }\n        }\n\n        // Depending on if the IP address assignment using DHCP has been successful or not,\n        // send the appropriate information back to the host.\n        // If External mode over TCP/IP or Wifi, do not print this Info. Information of IP address will be printed as\n        // a part of rtiostream_open\n        #if (!(defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)))\n        if (configureSuccess==1)\n        {\n            if(Ethernet.localIP()[0] == 0 || Ethernet.localIP()[0] == 255)\n            {\n                /*Tried to assign Static IP, failed due to one of the following reasons :\n                * 1. Ethernet shield is not connected properly with Arduino.\n                * 2. Ethernet shield is not connected to a network.\n                **/\n                Serial.println(\"<<<IP address: Failed to configure.>>>\");\n            }\n            else\n            {\n                // If the Configuration is successful, relay back the assigned IP address.\n                Serial.print(\"<<<IP address: \");\n                for (byte thisByte = 0; thisByte < 4; thisByte++)\n                {\n                    // Print the value of each byte of the IP address:\n                    Serial.print(Ethernet.localIP()[thisByte], DEC);\n                    if (thisByte<3)\n                    {\n                        Serial.print(\".\");\n                    }\n                }\n                Serial.println(\">>>\");\n            }\n        }\n        else\n        {\n            // If the Configuration failed,relay back the error message.\n            Serial.println(\"<<<IP address: Failed to configure.>>>\");\n        }\n        Serial.flush();\n        #endif\n\n        #if _RTT_TCP_ != 0\n        // Begin all servers based on the number of different TCP ports.\n        for (int i = 0;i < _RTT_TCP_;i++)\n        {\n            server[i].begin();\n        }\n        #endif\n        only_one_tcp_server_and_ethernet_begin = 1;\n    }\n}\n#endif\n#if _RTT_TCP_ != 0\nextern \"C\" void MW_TCPFinalread(uint8_t tcpindex, uint8_t *data, uint32_t serverport, int32_t *outStatus)\n{\n    int libFcnOutput;\n    EthernetClient client = server[tcpindex].available();\n    if (int(client) == true) {\n        libFcnOutput = client.read();\n        *data = (uint8_t) libFcnOutput;\n        *outStatus = (libFcnOutput != -1);\n\n    }\n    else\n    {\n        //When the client is not connected the status flag is accordingly toggled.\n        *outStatus = 0;\n    }\n\n}\nextern \"C\" void MW_TCPFinalWrite(uint8_t tcpindex, uint8_t data, uint32_t serverport)\n{\n    server[tcpindex].write(data);\n}\n#endif\n\n\n#if defined(_ROTH_LEONARDO_)\nextern \"C\" void MW_usbattach()\n{\n    USBDevice.attach();\n}\n#elif defined(ARDUINO_VIRTUAL_COM_PORT)\nextern \"C\" void MW_usbattach()\n{\n    __libc_init_array();\n    USBDevice.init();\n    USBDevice.attach();\n\n}\n#endif\n\nextern \"C\" void MW_pinModeExternalInterrupt(uint8_t pinNumber)\n{\n    pinMode(pinNumber, INPUT_PULLUP);\n}\n\nextern \"C\" void MW_delay_in_milliseconds(uint32_T period)\n{\n    uint32_T start_time = 0;\n    start_time = millis();\n    while(millis()- start_time <= period)\n    {\n        1;\n    }\n}\n\nextern \"C\" void MW_delay_in_microseconds(uint32_T period)\n{\n    uint32_T start_time = 0;\n    start_time = micros();\n    while(micros()- start_time <= period)\n    {\n        1;\n    }\n}\n\nextern \"C\" uint32_T MW_getCurrentTime_in_milliseconds()\n{\n   return (uint32_T)millis();\n}\n\n\n// #if defined(ARDUINO_ARDUINO_NANO33BLE)\n// #include \"Arduino.h\"\n// #include \"pins_arduino.h\"\n// #include \"mbed/drivers/AnalogIn.h\"\n// #include \"mbed.h\"\n//\n// extern uint8_t nano33BLE_dutycycle[21];\n// extern uint16_t nano33BLE_period[21];\n//\n//\n// events::EventQueue queue(32 * EVENTS_EVENT_SIZE);\n// rtos::Thread t;\n// mbed::Ticker tick;\n//\n// static int write_resolution = 8;\n// static int read_resolution = 10;\n//\n// extern \"C\" void MW_NANO33BLE_analogWrite_1(pin_size_t pin, int val, uint16_t period)\n// {\n//   if (pin >= PINS_COUNT) {\n//     return;\n//   }\n//   float percent = (float)val/(float)((1 << write_resolution)-1);\n//   mbed::PwmOut* pwm = digitalPinToPwm(pin);\n//   if (pwm == NULL) {\n//     pwm = new mbed::PwmOut(digitalPinToPinName(pin));\n//     digitalPinToPwm(pin) = pwm;\n//     pwm->period_ms(period);\n//   }\n//   pwm->write(percent);\n// }\n//\n// extern \"C\" void MW_NANO33BLE_PWM_Handler()\n// {\n//     MW_NANO33BLE_analogWrite_1(5, nano33BLE_dutycycle[5], nano33BLE_period[5]);\n// }\n//\n// extern \"C\" void MW_NANO33BLE_PWM_Setup()\n// {\n//   t.start(callback(&queue, &events::EventQueue::dispatch_forever));\n//   tick.attach(queue.event(MW_NANO33BLE_PWM_Handler),_RTT_PWM_PIN5_CST );\n// }\n//\n//\n//\n//\n// extern \"C\" void MW_NANO33BLE_analogWrite(PinName pin, int val, uint16_t period)\n// {\n// //   pin_size_t idx = PinNameToIndex(pin);\n// //   if (idx != NOT_A_PIN) {\n// //     MW_NANO33BLE_analogWrite_1(idx, 50, period);\n// //   } else {\n// //     mbed::PwmOut* pwm = new mbed::PwmOut(pin);\n// //     pwm->period_ms(2);\n// //     float percent = (float)50/(float)((1 << write_resolution)-1);\n// //     pwm->write(percent);\n// //   }\n// }\n//\n// #endif\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};